<!doctype html><html lang="en"><head><title data-lf="head">Longform Markup Language</title><meta data-lf="head" name="description" content="A markup and templating language for producing HTML and XML document fragments."><meta data-lf="head" name="viewport" content="width=device-width, initial-scale=1.0"><style>:root, body {
  margin: 0;
  padding: 0;
  font-size: 18px;
  line-height: 26px;
  font-family: sans-serif;
  --body-width: 45rem;
}
body {
  padding-left: 1rem;
  padding-right: 1rem;
  padding-bottom: 5rem;
}
header, main {
  width: 100%;
  max-width: 45rem;
  margin-top: 4rem;
  margin-left: auto;
  margin-right: auto;
}
section {
  margin-bottom: 3rem;
}
hgroup p {
  font-style: italic;
}
main {
  anchor-name: --main;
}
#toc, #toc ul, #toc li {
  list-style-type: none;
}
#toc {
  padding-left: 0;
  ul {
    padding-left: 1rem;
  }
}
a:visited {
  color: blue;
}
p {
  font-size: 1rem;
}
small {
  font-size: .8rem;
}
aside:not(.warning):not(.notice) {
  font-family: serif;
  font-style: italic;
}
aside.notice {
  border: solid .25rem blue;
  padding: .25rem 1rem;
}
aside.warning {
  border: solid .25rem red;
  padding: .25rem 1rem;
}
pre {
  background-color: #e4e4e4;
  width: 100%;
  box-sizing: border-box;
  margin-bottom: 1rem;
  padding: .5rem;
  border-radius: 3px;
  overflow-x: auto;
}
dd {
  margin-left: 0;
  margin-bottom: 2rem;
}
details {
  border: solid 1px #333333;
  border-radius: 3px;
  padding: .5rem;
  >:last-child {
    margin-bottom: 0;
  }
}
@media screen and (min-width: 90rem) and (min-height: 510px) {
  #toc {
    position: fixed;
    left: calc(50dvw - 38rem);
  }
}
@media screen and (min-width: 90rem) and (max-height: 670px) {
  #toc {
    bottom: 2rem;
  }
}
</style></head><body><header><hgroup><h1>Longform Markup Language</h1><p>A markup and templating language for producing <b class=keyword> HTML</b> and <b class=keyword>XML</b> document fragments.</p></hgroup><nav><ul id="toc"><li><b><a href="#language-intro">Language Intro</a></b></li><li><b><a href="#syntax">Syntax</a></b></li><li><b><a href="#fragments">Fragments</a></b></li><li><b><a href="#whitespace">Whitespace</a></b></li><li><b><a href="#elements">Elements</a></b></li><li><b><a href="#preformatted-blocks">Preformatted blocks</a></b></li><li><b><a href="#comments">Comments</a></b></li><li><b><a href="#embedding-fragments">Embedding fragments</a></b></li><li><b><a href="#templating">Templating</a></b></li><li><b><a href="#directives">Directives</a></b><ul><li><a href="#directive-url"><code>@url</code></a></li><li><a href="#directive-patchable"><code>@patchable</code></a></li><li><a href="#directive-doctype"><code>@doctype</code></a></li><li><a href="#directive-xml"><code>@xml</code></a></li><li><a href="#directive-editable"><code>@editable</code></a></li><li><a href="#directive-global"><code>@global</code></a></li><li><a href="#directive-allow-elements"><code>@allow-elements</code></a></li><li><a href="#directive-allow-attributes"><code>@allow-attributes</code></a></li><li><a href="#directive-allow-data-attributes"><code>@allow-data-attributes</code></a></li><li><a href="#directive-allow-all"><code>@allow-all</code></a></li></ul></li></ul></nav></header><main id="main"><aside id="wip-notice" class="warning"><p><strong>This document and the parser that creates it are works in progress. View the <a href="https://github.com/occultist-dev/longform/blob/main/spec/intro.lf">Longform source file</a> to get a feel for the language.</strong></p></aside> <section id="language-intro"><h2>Language Intro</h2><p><b class=keyword>Longform</b> is an easy to read markup and templating language that outputs to <b class=keyword>HTML</b> and <b class=keyword>XML</b>. A longform document can be parsed to a complete document in the output format or as fragments to be used by a application as a source of markup when generating a document, or when manipulating DOM in a browser environment.</p><pre><code>header::
  hgroup::
    h1:: Longform Markup Language
    p::
      A markup and templating language for producing
      &lt;b class=keyword&gt;HTML&lt;/b&gt; and &lt;b class=keyword&gt;
      XML&lt;/b&gt; document fragments.
</code></pre><details><summary>Result</summary><pre><samp>&lt;header&gt;
  &lt;hgroup&gt;
    &lt;h1&gt;Longform Markup Language&lt;/h1&gt;
    &lt;p&gt;
      A markup and templating language
      for producing &lt;b class=&quot;keyword&quot;&gt;
      HTML&lt;/b&gt; and &lt;b class=&quot;keyword&quot;&gt;XML
      &lt;/b&gt; document fragments.
    &lt;/p&gt;
  &lt;/hgroup&gt;
&lt;/header&gt;
</samp></pre></details><p>Unlike <b class=keyword>Markdown</b>, which excels in marking up article content but cannot express more recent additions to the HTML spec without falling back to HTML, the Longform syntax adds no constraints on the possible markup of the output format. As a result Longform plays well with custom HTML elements and elements and attributes which might be added to HTML in the future. And in being able to express elements such as <code>&lt;nav&gt;</code> or <code>&lt;head&gt;</code> it can be used effectively for static content markup for regions of the website beyond the main content.</p><p>Longform also supports directives which alter how a block of Longform or plain HTML / XML is processed. This specification will formalize directives which may be used in a browser environment using a minimal Longform parser.</p><p>For example, in a Longform template the directives <code>@allow-elements</code> and <code>@allow-attributes</code> can be used to allow user defined markup to be used in a template while filtering out any exempt markup. User input markup in the Longform syntax will have filtering rules applied by the Longform parser, while embedded HTML or XML content will require that an external serializer such as <a href=https://github.com/cure53/DOMPurify>DOMPurify</a> is configured to hook into the parser and apply the rules to the user defined content.</p><pre aria-describedby="template-sanitization-example"><code>@template
##card
section.card.note-#{position}::
  header::
    h3:: #{title}
  @allow-attributes:: lang dir
  @allow-elements:: details[open name] summary h4 p strong em a[href target]
  div.card-content::
    ##{content}
</code></pre><aside id="template-sanitization-example"><p><small>In a longform template the <code>#{title}</code> variable expansion escapes any unsafe HTML and XML entities whereas the <code>##{content}</code> expansion will filter any elements and attributes not explicitly allowed by the directive from the resulting markup. These directives can be used many times through a document allowing user defined markup to have rules appropriate for the context.</small></p></aside><p>Finally, the work in progress Longform parser is small and fast. Currently at 1.8kb when minified and gzipped and supporting most intended features for the browser environment. The parser is likely to grow but is unlikely to reach near the size of Commonmark at 47.6kb or Marked at 12kb. The parser is also fast, as it can complete its job by building up the resulting HTML fragment strings line by line instead of with a two step process of constructing and abstract syntax tree and then forming the valid output markup.</p></section>  <section id="fragments"><h2>Fragments</h2><aside><p>Longform's primary design goal is to output fragments of HTML in a form that can be rendered by another program into a complete HTML document, and when loaded as DOM in a browser, the fragments can be re-selected and referenced by a Javascript runtime. Since all Longform fragments are static content a Javascript runtime can re-use the existing DOM (or clones of) created from a Longform fragment and avoid hydration or re-rendering techniques that are often used by client side libraries, instead making sure that an equivilent DOM node is located in the correct location within the DOM if the runtime is rendering content around it.</p><p>To achieve this, depending on the fragment kind, a parser will embed HTML ids or data attributes in a fragment and expose valid selectors so the fragments can later be selected from the DOM.</p><p>Aside from the root fragment, all fragments should have a unique Longform identifier assigned to them so they can be referenced within the document or from the parsed content.</p></aside><h3>The root fragment</h3><p>The root fragment is an optional fragment that has no Longform identifier. There can be only one root fragment in a Longform document.</p><p>The root element of the root fragment has no whitespace preceeding it. The fragment has no Longform identifier but the root element can have a HTML identifier defined on it.</p><p>After a root fragment is found in the process of parsing a Longform document, all other fragments which do not have Longform identifiers assigned are ignored when rendering the output markup. The root fragment often would have the <a href="#directive-doctype"><code>@doctype</code></a> or <a href="#directive-xml"><code>@xml</code></a> directive prefixing it to add a <b class=keyword>HTML</b> doctype or <b class=keyword>XML</b> declaration prefixing the output markup.</p><pre><code>@doctype:: html
html::
  head::
    title:: Example Root Fragment
  body::
    h1:: Example Root Fragment
</code></pre><details><summary>Result</summary><pre><samp>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Example Root Fragment&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Example Root Fragment&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</samp></pre></details><h3>Fragments with embedded identifiers</h3><p>Fragments can have their Longform identifier embedded into the output markup as a HTML or XML id. Embedded ids should be unique to both the target document and Longform document. If a Longform fragment references a fragment with an embedded identifier, any other attempts to reference the embedded fragment will be ignored by the Longform parser. Fragments with embeded identifiers will also not be exported to be directly referenced by external software if they have been referenced in the Longform document.</p><pre><code>#embedded-id
section::
  p:: A fragment that can be referenced by its &lt;a href=#embedded-id&gt;identifier&lt;/a&gt;
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;section id=&quot;embedded-id&quot;&gt;
  &lt;p&gt;
    A fragment that can be referenced by its &lt;a href=&quot;#embedded-id&quot;&gt;identifier&lt;/a&gt;
  &lt;/p&gt;
&lt;/section&gt;
</code></samp></pre></details><h3>Bare fragments</h3><p>Bare fragments have ids that can be referenced many times within the same Longform document and are always outputted to be used by external software. The given id is written to the output markup as a data attribute instead of an id.</p><pre><code>##alert-something-went-wrong
dialog[open].error::
  p::
    strong:: Something went wrong!
  form[method=dialog]::
    button:: Close
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;dialog data-lf=&quot;alert-something-went-wrong&quot; open class=&quot;error&quot;&gt;
  &lt;strong&gt;Something went wrong!&lt;/strong&gt;
  &lt;form method=&quot;dialog&quot;&gt;
    &lt;button&gt;Close&lt;/botton&gt;
  &lt;/form&gt;
&lt;/dialog&gt;
</code></samp></pre></details><h3>Range fragments</h3><p>Range fragments can have more than one topmost element which are outputted as siblings. All top-most elements of the range fragment would have the same data attribute.</p><pre><code>#head-details [
  title:: The range fragment
  meta::
    [name=description]
    [content=Demonstraiting the range fragment]
]
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;title data-lf=&quot;head-details&quot;&gt;A range of fragments&lt;/title&gt;
&lt;meta data-lf=&quot;head-details&quot; name=&quot;description&quot; content=&quot;Demonstraiting the range fragment&quot; /&gt;
</code></samp></pre></details><h3>Text fragments</h3><p>Text fragments do not include any elements. Programs using Longform output can use text fragments in locations where elements are not allowed such as HTML attributes. Text fragments are particulaly useful where Longform is being used as a master document for all translated copy for a webpage.</p><pre><code>#aria-label &quot;
  Create a recipe
&quot;
</code></pre><details><summary>Result</summary><pre><samp><code>Create a recipe
</code></samp></pre></details></section> <section id="whitespace"><h2>Whitespace</h2><p>Whitespace is meaningful in <strong>Longform</strong>. Any markup indented two spaces out from an element will be outputted as a child of that element.</p><p>Some exceptions for this are when native markup of the output language and text are being processed. Or when in a <a href="#preformatted-blocks">preformatted block</a>.</p></section> <section id="elements"><h2>Declaring elements</h2><h3>Element tags</h3><p>A sole element tag can be outputted using the element name followed by two colons <code>::</code>.</p><pre><code>div::
</code></pre><h3>Element attributes</h3><p>Element attributes are declared after the tag and are wrapped in square brackets <code>[]</code>.</p><pre><code>div[data-foo=bar][aria-describedby=#baz]::
</code></pre><p>Alternatively attributes can follow directly after the element tag with 1 level of indentation.</p><pre><code>div::
  [data-foo=bar]
  [aria-describedby=#baz]
</code></pre><p>If an element is declared multiple times the content is concatinated into a single value. This behaviour does not apply to the element's id if it is defined using the attribute syntax. Classes will be concatinated with a space separating them.</p><pre><code>meta::
  [name=description]
  [content=Lorem ipsum dolor sit amet, consectetur adipiscing elit.]
  [content=Quisque a sem et nisl mollis porttitor et sit amet neque.]
  [content=Maecenas suscipit nulla ac suscipit imperdiet. Quisque]
  [content=odio nisi, semper non dui quis, feugiat faucibus ipsum.]
</code></pre><h3>Element output ids</h3><p>The elements output markup id can be declared on the line before the tag at the same indentation level with the hash <code>#</code> symbol pre-fixing the id.</p><p>This form of giving an element an id also gives it a meaningful Longform identifier.</p><pre><code>#element-id
div::
</code></pre><p>Alternatively the id can follow the tag name, before the closing semicolons. Again with a hash prefixing it. Unlike the form where the</p><pre><code>div#element-id::
</code></pre><p>And finally the id can be declared using the attribute syntax.</p><pre><code>div[id=element-id]::
&lt;!-- or --&gt;
div::
  [id=element-id]
</code></pre><p>If an element has an id declared for it twice only the first declaration is used.</p><h3>Element classes</h3><p>Classes can be defined following the element's tag declaration with a period <code>.</code> prefixing each tag.</p><pre><code>div#element-id.class-1.class-2.class-3::
</code></pre><p>Alternatively classes can be defined using the attribute syntax on the lines following the tag definition.</p><pre><code>div#element-id::
  [class=class-1]
  [class=class-2 class-3]
</code></pre><h3>Element text and native markup content.</h3><p>Elements can have text and native markup following the tag declaration with a space between the text and the double colons of the element definition.</p><pre><code>div:: Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre><p>Alternatively, the text and native markup can follow the tag declaration with one extra indentation level.</p><pre><code>div::
  Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre></section> <section id="preformatted-blocks"><h3>Preformatted blocks</h3><p>Longform does not assign special meaning to any HTML tags so to retain formatting content can be wrapped in curly braces to create a preformatted block.</p><dl><dt><b>Escaped preformatted block</b></dt><dd>When an element is followed by a single curly brace, its content is HTML escaped and its whitespace is preserved at the children's indent level.<pre><code>pre::
  code:: {
    div::
      &lt;p&gt;
        This content will preserve its formatting including
        the parent &lt;code&gt;div::&lt;/code&gt;
      &lt;/p&gt;
  }
</code></pre><details><summary>Result</summary><pre><samp>&lt;pre&gt;&lt;code&gt;
  div::
    &lt;p&gt;
      This content will preserve its formatting including
      the parent &lt;code&gt;div::&lt;/code&gt;
    &lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;
</samp></pre></details></dd><dt><b>Un-escaped preformatted text</b></dt><dd>When an element is followed by a two curly braces, its formatting and content is kept intact.<pre><code>script:: {{
  console.log(&apos;Hello, World!&apos;);
}}
style:: {{
  div {
    color: red;
  }
}}
</code></pre><details><summary>Result</summary><pre><samp>&lt;script&gt;
  console.log(&apos;Hello, World!&apos;);
&lt;/script&gt;&lt;style&gt;
  div {
    color: red;
  }
&lt;/style&gt;
</samp></pre></details></dd></dl></section> <section id="comments"><h2>Comments</h2><p>Comments can be written outside of a fragment using <code>--</code> two hyphens. Within a fragment comments in the output markup language's syntax can be used but they will be written to the output alongside all other text in the native output markup.</p></section> <section id="embedding-fragments"><h2>Embedding fragments</h2><p>Fragments can be embedded into other fragments as part of the longform parsing allowing a full document to be created from many fragments. Fragments are embedded using the syntax &num;[fragment-id].</p><pre><code>main#main::
  #[wip-notice]
  #[language-intro]
  #[syntax]
  #[fragments]
  #[whitespace]
  #[elements]
  #[preformatted-blocks]
  #[templating]
  #[selecting-from-dom]
  #[mediatype]
  #[server-side-usage]
  #[directives]
</code></pre></section> <section id="templating"><h2>Templating</h2><aside class="notics"><p>Longform templates are intended for client side templating where Javascript may be performing any required logic before calling the template. Future versions of Longform will include pre-processing templates which have more functionality.</p><p>When a longform document is procecsed, any templates will be provided as strings intented to be re-processed using a separate template processing function which knows how to expand any variables in the template.</p></aside><p>Longform templates only allow key-value pairs inputed with the values being strings. The template is intended to be passed over to the client where the template might be rendered using client side state. It is assumed that the client has its own means to perform conditional statements and iterate, and is optimized to do so, so those functionalities are left to the scripting language to keep the templating logic lean.</p><pre><code>@template
div::
  h3:: Recipe step #{position}
</code></pre></section>    <section id="directives"><h2>Directives</h2><dl><dt id="directive-url"><b><code>@url</code></b></dt><dd><p>Sets the URL of the Longform document. A HTTP Get request to the <code>@url</code> using the <code>Accept</code> header <b>text/longform</b> should produce the same document unless it has since been modified.</p><pre><code>@url:: https://example.com/blog/article-1
</code></pre></dd><dt id="directive-patchable"><b><code>@patchable</code></b></dt><dd><p>Asserts to the client that the document can be patched using a HTTP Patch request and the <code>Content-Type</code> header <b>text/longform</b>. The <code>@patchable</code> directive should be ignored unless the <code>@url</code> directive is used.</p><pre><code>@url:: http://example.com/blog/longform-1
@patchable
</code></pre></dd><dt id="directive-doctype"><b><code>@doctype</code></b></dt><dd><p>Inserts a doctype declaration before a fragment starts.</p><pre><code>@doctype:: html
html[lang=en]::
  head::
    ...
  body::
    ...
</code></pre><details><summary>Result</summary><pre><samp>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;...&lt;/head&gt;
  &lt;body&gt;...&lt;/body&gt;
&lt;/html&gt;
</samp></pre></details></dd><dt id="directive-xml"><b><code>@xml</code></b></dt><dd><p>Inserts an XML declaration before a fragment starts.</p><pre><code>@xml:: version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;
html::
  [xmlns=http://www.w3.org/HTML/1998/html4]
  [xmlns:xdc=http://www.xml.com/books]
  body::
    ...
</code></pre><details><summary>Result</summary><pre><samp>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;html
  xmlns=&quot;http://www.w3.org/HTML/1998/html4&quot;
  xmlns:xdc=&quot;http://www.xml.com/books&quot;
&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;
</samp></pre></details></dd><dt id="directive-editable"><b><code>@editable</code></b></dt><dd><p>Marks the children of an element as editable in a patch request. The element cannot be within a template and must have a Longform id set on it.</p><pre><code>@editable
#edit-me
div::
  This content is editable.
</code></pre></dd><dt id="directive-global"><b><code>@global</code></b></dt><dd><p>Applies directive rules to an entire Longform document. Directives applied before or within a fragment will typically override globally set rules.</p><pre><code>@url:: https://example.com/pages/article-1
@patchable
@global::
  @allowed-elements:: h4 p strong em b i small hr br
</code></pre></dd><dt id="directive-allow-elements"><b><code>@allow-elements</code></b></dt><dd><p>In a template this directive instructs the parser what elements can be rendered when applying non-escaped variable expansion within its scope. If used in a patchable document, client side editors should limit what elements can be edited in the editable element. The directive's rules should also be used to sanitize or reject input when merging edits from a HTTP Patch request into the document on the server.</p><p>Attributes can be allowed on specific elements by listing them in square brackets directly after the element in the directive's arguments.</p><p>If this or the <code>@allow-all</code> directives are not used all elements should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-elements:: a[href target] p strong em
div::
  Edit me!
</code></pre></dd><dt id="directive-allow-attributes"><b><code>@allow-attributes</code></b></dt><dd><p>In a template this directive instructs the parser what attributes can be rendered when applying non-escaped variable expansion within its scope. If used in a patchable document client side editors can limit what attributes can be added to the markup. The directive's rules should be used to sanitize or reject input when merging edits from a HTTP Patch request into the document on the server.</p><p>If this or the <code>@allow-all</code> directives are not used all attributes should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-attributes:: id name class
@allow-elements:: a[href target] p strong em form label[for] input button[submit]
div::
  Edit me...
</code></pre></dd><dt id="directive-allow-data-attributes"><b><code>@allow-data-attributes</code></b></dt><dd><p>In a template this directive instructs the parser to allow rendering of data-attributes when applying non-escaped variable expansion within its scope. If used in a patchable document client side editors can allow data-attributes to be added to the markup.</p><p>If this or the <code>@allow-all</code> directives are not used all data-attributes should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-data-attributes
@allow-attributes:: id name class
@allow-elements:: a[href target] p strong em form label[for] input button[submit]
div::
  Edit me...
</code></pre></dd><dt id="directive-allow-all"><b><code>@allow-all</code></b></dt><dd><p>This directive instructs the parser to allow all elements, attributes and data-attributes when performing non-escaped variable expansion or when editing a patchable document.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-all
body::
  Edit me...
</code></pre></dd><dt id="preprocess"><b><code>@preprocess</code></b></dt><dd><p>This directive should be used at the top level of a fragment to instruct a Longform pre-processor to</p></dd></dl></section></main></body></html>