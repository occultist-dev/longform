{
  "version": 3,
  "sources": ["../lib/longform.ts"],
  "sourcesContent": ["import type { ChunkType, FragmentType, ParsedResult, WorkingChunk, WorkingElement, WorkingFragment, Fragment } from \"./types.ts\";\n\nexport type {\n  FragmentType,\n  Fragment,\n  ParsedResult\n};\n\nconst sniffTestRe = /^(?:(?:(--).*)|(?: *(@|#).*)|(?: *[\\w\\-]+(?::[\\w\\-]+)?(?:[#.[][^\\n]+)?(::).*)|(?:  +([\\[\"]).*)|(\\ \\ .*))$/gmi\n  , element1 = /((?:\\ \\ )+)? ?([\\w\\-]+(?::[\\w\\-]+)?)([#\\.\\[][^\\n]*)?::(?: ({{?|[^\\n]+))?/gmi\n  , directive1 = /((?:\\ \\ )+)? ?@([\\w][\\w\\-]+)(?::: ?([^\\n]+)?)?/gmi\n  , attribute1 = /((?:\\ \\ )+)\\[(\\w[\\w-]*(?::\\w[\\w-]*)?)(?:=([^\\n]+))?\\]/\n  , preformattedClose = /[ \\t]*}}?[ \\t]*/\n  , id1 = /((?:\\ \\ )+)?#(#)?([\\w\\-]+)(?: ([\\[\"]))?/gmi\n  , idnt1 = /^(\\ \\ )+/\n  , text1 = /^((?:\\ \\ )+)([^ \\n][^\\n]*)$/i\n  , paramsRe = /(?:(#|\\.)([^#.\\[\\n]+)|(?:\\[(\\w[\\w\\-]*(?::\\w[\\w\\-]*)?)(?:=([^\\n\\]]+))?\\]))/g\n  , refRe = /#\\[([\\w\\-]+)\\]/g\n  , escapeRe = /([&<>\"'#\\[\\]{}])/g\n  , templateLinesRe = /^(\\ \\ )?([^\\n]+)$/gmi\n  , voids = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wrb']);\n\nlet m1: RegExpExecArray | null\n  , m2: RegExpExecArray | null\n  , m3: RegExpExecArray | null;\n\nconst entities = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&apos;',\n//  '#': '&num;',\n//  '[': '&lbrak;',\n//  ']': '&rbrak;',\n//  '{': '&rbrace;',\n//  '}': '&lbrace;',\n};\n\nfunction escape(value: string): string {\n  return value.replace(escapeRe, (match) => {\n    return entities[match] ?? match;\n  });\n}\n\nfunction makeElement(indent: number = 0): WorkingElement {\n  return {\n    indent,\n    html: '',\n    attrs: {},\n  };\n}\n\nfunction makeChunk(type: ChunkType = 'parsed'): WorkingChunk {\n  return {\n    type,\n    html: '',\n    els: [],\n  };\n}\n\nfunction makeFragment(type: FragmentType = 'bare'): WorkingFragment {\n  return {\n    type,\n    html: '',\n    template: false,\n    els: [],\n    chunks: [],\n    refs: [],\n  };\n}\n\n/**\n * Parses a longform document into a object containing the root and fragments\n * in the output format.\n *\n * @param {string} doc - The longform document to parse.\n * @returns {ParsedResult}\n */\nexport function longform(doc: string, debug: (...d: unknown[]) => void = () => {}): ParsedResult {\n  let skipping: boolean = false\n    , textIndent: number | null = null\n    , verbatimSerialize: boolean = true\n    , verbatimIndent: number | null = null\n    , verbatimFirst: boolean = false\n    , element: WorkingElement = makeElement()\n    , chunk: WorkingChunk | null = makeChunk()\n    , fragment: WorkingFragment = makeFragment()\n    // the root fragment\n    , root: WorkingFragment | null = null\n    // ids of claimed fragments\n  const claimed: Set<string> = new Set()\n    // parsed fragments\n    , parsed: Map<string, WorkingFragment> = new Map()\n    , output: ParsedResult = Object.create(null);\n\n  output.fragments = Object.create(null);\n  output.templates = Object.create(null);\n  \n  \n  /**\n   * Closes any current in progress element definition\n   * and creates a new working element.\n   */\n  function applyIndent(targetIndent: number) {\n    if (element.tag != null) {\n      const root = fragment.type === 'range'\n        ? targetIndent < 2\n        : fragment.html === ''\n      ;\n\n      fragment.html += `<${element.tag}`\n\n      if (root) {\n        if (fragment.type === 'root') {\n          fragment.html += ` data-lf-root`;\n        } else if (fragment.type === 'bare' || fragment.type === 'range') {\n          fragment.html += ` data-lf=\"${fragment.id}\"`;\n        }\n      }\n\n      if (element.id != null) {\n        fragment.html += ' id=\"' + element.id + '\"';\n      }\n\n      if (element.class != null) {\n        fragment.html += ' class=\"' + element.class + '\"';\n      }\n\n      for (const attr of Object.entries(element.attrs)) {\n        if (attr[1] == null) {\n          fragment.html += ' ' + attr[0]\n        } else {\n          fragment.html += ` ${attr[0]}=\"${attr[1]}\"`;\n        }\n      }\n\n      fragment.html += '>';\n\n      if (!voids.has(element.tag as string) && element.text != null) {\n        fragment.html += element.text;\n      }\n\n      if (\n        !voids.has(element.tag as string)\n      ) {\n        fragment.els.push(element);\n      }\n    }\n\n    if (targetIndent <= element.indent) {\n      element = makeElement(targetIndent);\n\n      while (\n        fragment.els.length !== 0 && (\n          targetIndent == null ||\n          fragment.els[fragment.els.length - 1].indent !== targetIndent - 1\n        )\n      ) {\n        const element = fragment.els.pop();\n\n        fragment.html += `</${element?.tag}>`;\n      }\n\n      if (targetIndent === 0) {\n        debug(0, '<', fragment.type, fragment.id);\n        if (fragment.template) {\n          output.templates[fragment.id] = fragment.html;\n        } else if (fragment.type === 'root') {\n          root = fragment;\n        } else {\n          parsed.set(fragment.id, fragment);\n        }\n\n        fragment = makeFragment();\n      }\n    } else {\n      element = makeElement(targetIndent)\n    }\n  }\n\n  while ((m1 = sniffTestRe.exec(doc))) {\n    if (m1[1] === '--') {\n      continue;\n    } else if (fragment.template) {\n      fragment.html += m1[0];\n    }\n\n    // If this is a script tag or preformatted block\n    // we want to retain the intended formatting less\n    // the indent. Preformatting can apply to any element\n    // by ending the declaration with `:: {`.\n    if (verbatimIndent != null) {\n      // inside a script or preformatted block\n      idnt1.lastIndex = 0;\n      m2 = idnt1.exec(m1[0]);\n      const indent = m2 == null\n        ? null\n        : m2[0].length / 2;\n\n      if (m2 == null || indent as number <= verbatimIndent) {\n        fragment.html += '\\n';\n        debug(indent, '}', m2?.[0]);\n\n        applyIndent(indent);\n        verbatimIndent = null;\n        verbatimFirst = false;\n        textIndent = indent;\n\n        if (preformattedClose.test(m1[0])) {\n          continue;\n        }\n      } else {\n        const line = m1[0].replace('  '.repeat(verbatimIndent + 1), '');\n        debug(indent, '{', line);\n\n        if (element.tag != null) {\n          applyIndent(indent as number);\n        }\n\n        if (verbatimFirst) {\n          verbatimFirst = false;\n        } else {\n          fragment.html += '\\n';\n        }\n        \n        if (verbatimSerialize) {\n          fragment.html += escape(line);\n        } else {\n          fragment.html += line;\n        }\n\n        continue;\n      }\n    }\n\n    if (m1[0].trim() === '') {\n      continue;\n    }\n\n    switch (m1[2] ?? m1[3] ?? m1[4]) {\n      // deno-lint-ignore no-fallthrough\n      case '#': {\n        id1.lastIndex = 0;\n        m2 = id1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n\n          if (element.tag != null || textIndent != null) {\n            applyIndent(indent);\n            textIndent = null;\n          }\n\n          debug(indent, 'id', m2[2], m2[3], m2[4]);\n\n          fragment.id = m2[3];\n\n          if (indent === 0) {\n            if (m2[4] == '[') {\n              fragment.type = 'range';\n            } else if (m2[4] === '\"') {\n              fragment.type = 'text';\n            } else if (m2[2] != null) {\n              fragment.type = 'bare';\n            } else {\n              fragment.type = 'embed';\n              element.id = fragment.id;\n            }\n          }\n\n          break;\n        }\n      }\n      case '@':\n      case '[':\n      // deno-lint-ignore no-fallthrough\n      case '::': {\n        element1.lastIndex = 0;\n        // fall through if m1[3] is a # or @\n        m2 = m1[2] ?? m1[4] != null\n           ? null\n           : element1.exec(m1[0]);\n\n        // if null then invalid element selector\n        // allow the default text case to handle\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2\n              , tg = m2[2]\n              , ar = m2[3]\n              , pr = m2[4] === '{' || m2[4] === '{{'\n          const tx = pr ? null : m2[4]\n\n          debug(indent, 'e', tg, pr, tx);\n\n          if (\n            element.tag != null ||\n            element.indent > indent\n          ) {\n            applyIndent(indent);\n          }\n\n          element.indent = indent;\n          element.tag = tg;\n\n          textIndent = null;\n          \n          if (indent === 0 && fragment.id == null) {\n            if (root != null) {\n              skipping = true;\n            } else {\n              fragment.type = 'root';\n              root = fragment;\n            }\n          }\n          \n          if (ar != null) {\n            debug(indent, 'a', ar);\n            while ((m2 = paramsRe.exec(ar))) {\n              if (m2[1] === '#') {\n                element.id = m2[2];\n              } else if (m2[1] === '.') {\n                if (element.class == null) {\n                  element.class = m2[2];\n                } else {\n                  element.class += ' ' + m2[2];\n                }\n              } else {\n                if (m2[3] === 'id') {\n                  if (element.id == null) {\n                    element.id = m2[4];\n                  }\n                } else if (m2[3] === 'class') {\n                  if (element.class == null) {\n                    element.class = m2[4]\n                  } else {\n                    element.class += ' ' + m2[4]\n                  }\n                } else {\n                  element.attrs[m2[3]] = m2[4];\n                }\n              }\n            }\n          }\n\n          if (!pr && tx != null) {\n            element.text = tx;\n          } else if (pr) {\n            verbatimFirst = true;\n            verbatimIndent = indent;\n            verbatimSerialize = m2[4] === '{';\n          }\n\n          break;\n        }\n\n        attribute1.lastIndex = 0;\n        m2 = m1[2] != null\n           ? null\n           : attribute1.exec(m1[0]);\n\n        if (m2 != null && element.tag != null) {\n          debug('a', m2[2], m2[3]);\n\n          if (m2[2] === 'id') {\n            if (element.id == null) {\n              element.id = m2[3].trim();\n            }\n          } else if (m2[2] === 'class') {\n            if (element.class != null) {\n              element.class += ' ' + m2[3].trim();\n            } else {\n              element.class = m2[3].trim();\n            }\n          } else if (element.attrs[m2[2]] != null) {\n            element.attrs[m2[2]] += m2[3];\n          } else {\n            element.attrs[m2[2]] = m2[3];\n          }\n\n          break;\n        }\n\n        directive1.lastIndex = 0;\n        m2 = m1[3] != null\n            ? null \n            : directive1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n\n          if (element.tag != null || textIndent != null) {\n            applyIndent(indent);\n          }\n\n          debug(indent, 'd', m2[2], m2[3]);\n\n          switch (m2[2]) {\n            case 'doctype': {\n              fragment.html += `<!doctype ${m2[3] ?? 'html'}>`;\n              break;\n            }\n            case 'xml': {\n              fragment.html += `<?xml ${m2[3] ?? 'version=\"1.0\" encoding=\"UTF-8\"'}?>`;\n              break;\n            }\n            case 'template': {\n              let indented = false;\n              fragment.template = indent === 0;\n\n              templateLinesRe.lastIndex = sniffTestRe.lastIndex;\n              while ((m2 = templateLinesRe.exec(doc))) {\n                if (m2[1] == null && !indented && fragment.id == null) {\n                  id1.lastIndex = 0;\n                  m3 = id1.exec(m2[0]);\n\n                  if (m3 != null) fragment.id = m3[3];\n\n                  fragment.html += m2[0];\n                } else if (m2[1] == null && indented) {\n                  sniffTestRe.lastIndex = templateLinesRe.lastIndex - m2[0].length;\n                  break;\n                } else {\n                  fragment.html += '\\n' + m2[0];\n                  if (m2[1] != null) indented = true;\n                }\n              }\n\n              applyIndent(0);\n            }\n          }\n\n          break;\n        }\n\n      }\n      default: {\n        m2 = text1.exec(m1[0]) as RegExpExecArray;\n\n        if (m2 == null) {\n          break;\n        }\n        const indent = m2[1].length / 2;\n        const tx = m2[2].trim();\n\n        debug(indent, 't', m2[2]);\n\n        if (element.tag != null) {\n          applyIndent(indent);\n\n          fragment.html += tx;\n        } else if (fragment.type === 'text' && fragment.html === '') {\n          fragment.html += tx;\n        } else {\n          fragment.html += ' ' + tx;\n        }\n\n        textIndent = indent;\n\n        while ((m2 = refRe.exec(tx))) {\n          const start = fragment.html.length + m2.index - tx.length;\n\n          fragment.refs.push({\n            id: m2[1],\n            start,\n            end: start + m2[0].length,\n          });\n        }\n\n        break;\n      }\n    }\n  }\n\n  applyIndent(0);\n\n  const arr = Array.from(parsed.values());\n\n  function flatten(fragment: WorkingFragment): WorkingFragment {\n    // work backwards so we don't change the html string length\n    // for the later replacements\n    for (let j = fragment.refs.length - 1; j >= 0; j--) {\n      const ref = fragment.refs[j];\n\n      if (claimed.has(ref.id) || !parsed.has(ref.id)) {\n        fragment.html = fragment.html.slice(0, ref.start)\n          + fragment.html.slice(ref.end)\n      } else {\n        const child = flatten(parsed.get(ref.id));\n\n        fragment.html = fragment.html.slice(0, ref.start)\n          + child.html\n          + fragment.html.slice(ref.end);\n\n        if (child.type === 'embed') {\n          claimed.add(child.id)\n        }\n      }\n    }\n\n    fragment.refs = [];\n\n    return fragment;\n  }\n\n  for (let i = 0; i < parsed.size + 1; i++) {\n    let fragment: WorkingFragment;\n    \n    if (i === 0 && root == null) {\n      continue;\n    } else if (i === 0) {\n      fragment = root;\n    } else {\n      fragment = arr[i - 1];\n    }\n\n    if (fragment.refs.length === 0) {\n      continue;\n    }\n\n    flatten(fragment)\n  }\n\n  if (root?.html != null) {\n    output.root = root.html;\n    output.selector = `[data-lf-root]`;\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    let selector: string;\n    const fragment = arr[i];\n\n    if (fragment == null || claimed.has(fragment.id)) {\n      continue;\n    }\n\n    if (fragment.type === 'embed') {\n      selector = `[id=${fragment.id}]`;\n    } else if (fragment.type === 'bare') {\n      selector = `[data-lf=${fragment.id}]`;\n    } else if (fragment.type === 'range') {\n      selector = `[data-lf=${fragment.id}]`;\n    }\n\n    output.fragments[fragment.id] = {\n      id: fragment.id,\n      selector,\n      type: fragment.type as 'embed' | 'bare' | 'range',\n      html: fragment.html,\n    };\n  }\n\n  return output;\n}\n\n\nconst templateRe = /(?:#{([\\w][\\w\\-_]*)})|(?:#\\[([\\w][\\w\\-_]+)\\])/g;\n\n/**\n * Processes a client side Longform template to HTML fragment string.\n *\n * @param fragment    - The fragment identifier.\n * @param args        - A record of template arguments.\n * @param getFragment - A function which returns an already processed fragment's HTML string.\n * @returns The processed template.\n */\nexport function processTemplate(\n  template: string,\n  args: Record<string, string | number>,\n  getFragment: (fragment: string) => string | undefined,\n): string | undefined {\n  const lf = template.replace(templateRe, (_match, param, ref) => {\n    if (ref != null) {\n      const fragment = getFragment(ref);\n\n      if (fragment == null) return '';\n\n      return fragment;\n    }\n    \n    return args[param] != null ? escape(args[param].toString()) : '';\n  });\n\n  return Object.values(longform(lf).fragments)[0]?.html ?? null;\n}\n"],
  "mappings": "AAQA,MAAM,cAAc,gHAChB,WAAW,+EACX,aAAa,qDACb,aAAa,yDACb,oBAAoB,mBACpB,MAAM,8CACN,QAAQ,YACR,QAAQ,gCACR,WAAW,8EACX,QAAQ,mBACR,WAAW,qBACX,kBAAkB,wBAClB,QAAQ,oBAAI,IAAI,CAAC,QAAQ,QAAQ,MAAM,OAAO,SAAS,MAAM,OAAO,SAAS,QAAQ,QAAQ,SAAS,UAAU,SAAS,KAAK,CAAC;AAEnI,IAAI,IACA,IACA;AAEJ,MAAM,WAAW;AAAA,EACf,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAMP;AAEA,SAAS,OAAO,OAAuB;AACrC,SAAO,MAAM,QAAQ,UAAU,CAAC,UAAU;AAxC5C;AAyCI,YAAO,cAAS,KAAK,MAAd,YAAmB;AAAA,EAC5B,CAAC;AACH;AAEA,SAAS,YAAY,SAAiB,GAAmB;AACvD,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN,OAAO,CAAC;AAAA,EACV;AACF;AAEA,SAAS,UAAU,OAAkB,UAAwB;AAC3D,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN,KAAK,CAAC;AAAA,EACR;AACF;AAEA,SAAS,aAAa,OAAqB,QAAyB;AAClE,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAAA,IACN,UAAU;AAAA,IACV,KAAK,CAAC;AAAA,IACN,QAAQ,CAAC;AAAA,IACT,MAAM,CAAC;AAAA,EACT;AACF;AASO,gBAAS,SAAS,KAAa,QAAmC,MAAM;AAAC,GAAiB;AA/EjG;AAgFE,MAAI,WAAoB,OACpB,aAA4B,MAC5B,oBAA6B,MAC7B,iBAAgC,MAChC,gBAAyB,OACzB,UAA0B,YAAY,GACtC,QAA6B,UAAU,GACvC,WAA4B,aAAa,GAEzC,OAA+B;AAEnC,QAAM,UAAuB,oBAAI,IAAI,GAEjC,SAAuC,oBAAI,IAAI,GAC/C,SAAuB,uBAAO,OAAO,IAAI;AAE7C,SAAO,YAAY,uBAAO,OAAO,IAAI;AACrC,SAAO,YAAY,uBAAO,OAAO,IAAI;AAOrC,WAAS,YAAY,cAAsB;AACzC,QAAI,QAAQ,OAAO,MAAM;AACvB,YAAMA,QAAO,SAAS,SAAS,UAC3B,eAAe,IACf,SAAS,SAAS;AAGtB,eAAS,QAAQ,IAAI,QAAQ,GAAG;AAEhC,UAAIA,OAAM;AACR,YAAI,SAAS,SAAS,QAAQ;AAC5B,mBAAS,QAAQ;AAAA,QACnB,WAAW,SAAS,SAAS,UAAU,SAAS,SAAS,SAAS;AAChE,mBAAS,QAAQ,aAAa,SAAS,EAAE;AAAA,QAC3C;AAAA,MACF;AAEA,UAAI,QAAQ,MAAM,MAAM;AACtB,iBAAS,QAAQ,UAAU,QAAQ,KAAK;AAAA,MAC1C;AAEA,UAAI,QAAQ,SAAS,MAAM;AACzB,iBAAS,QAAQ,aAAa,QAAQ,QAAQ;AAAA,MAChD;AAEA,iBAAW,QAAQ,OAAO,QAAQ,QAAQ,KAAK,GAAG;AAChD,YAAI,KAAK,CAAC,KAAK,MAAM;AACnB,mBAAS,QAAQ,MAAM,KAAK,CAAC;AAAA,QAC/B,OAAO;AACL,mBAAS,QAAQ,IAAI,KAAK,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC;AAAA,QAC1C;AAAA,MACF;AAEA,eAAS,QAAQ;AAEjB,UAAI,CAAC,MAAM,IAAI,QAAQ,GAAa,KAAK,QAAQ,QAAQ,MAAM;AAC7D,iBAAS,QAAQ,QAAQ;AAAA,MAC3B;AAEA,UACE,CAAC,MAAM,IAAI,QAAQ,GAAa,GAChC;AACA,iBAAS,IAAI,KAAK,OAAO;AAAA,MAC3B;AAAA,IACF;AAEA,QAAI,gBAAgB,QAAQ,QAAQ;AAClC,gBAAU,YAAY,YAAY;AAElC,aACE,SAAS,IAAI,WAAW,MACtB,gBAAgB,QAChB,SAAS,IAAI,SAAS,IAAI,SAAS,CAAC,EAAE,WAAW,eAAe,IAElE;AACA,cAAMC,WAAU,SAAS,IAAI,IAAI;AAEjC,iBAAS,QAAQ,KAAKA,YAAA,gBAAAA,SAAS,GAAG;AAAA,MACpC;AAEA,UAAI,iBAAiB,GAAG;AACtB,cAAM,GAAG,KAAK,SAAS,MAAM,SAAS,EAAE;AACxC,YAAI,SAAS,UAAU;AACrB,iBAAO,UAAU,SAAS,EAAE,IAAI,SAAS;AAAA,QAC3C,WAAW,SAAS,SAAS,QAAQ;AACnC,iBAAO;AAAA,QACT,OAAO;AACL,iBAAO,IAAI,SAAS,IAAI,QAAQ;AAAA,QAClC;AAEA,mBAAW,aAAa;AAAA,MAC1B;AAAA,IACF,OAAO;AACL,gBAAU,YAAY,YAAY;AAAA,IACpC;AAAA,EACF;AAEA,SAAQ,KAAK,YAAY,KAAK,GAAG,GAAI;AACnC,QAAI,GAAG,CAAC,MAAM,MAAM;AAClB;AAAA,IACF,WAAW,SAAS,UAAU;AAC5B,eAAS,QAAQ,GAAG,CAAC;AAAA,IACvB;AAMA,QAAI,kBAAkB,MAAM;AAE1B,YAAM,YAAY;AAClB,WAAK,MAAM,KAAK,GAAG,CAAC,CAAC;AACrB,YAAM,SAAS,MAAM,OACjB,OACA,GAAG,CAAC,EAAE,SAAS;AAEnB,UAAI,MAAM,QAAQ,UAAoB,gBAAgB;AACpD,iBAAS,QAAQ;AACjB,cAAM,QAAQ,KAAK,yBAAK,EAAE;AAE1B,oBAAY,MAAM;AAClB,yBAAiB;AACjB,wBAAgB;AAChB,qBAAa;AAEb,YAAI,kBAAkB,KAAK,GAAG,CAAC,CAAC,GAAG;AACjC;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM,OAAO,GAAG,CAAC,EAAE,QAAQ,KAAK,OAAO,iBAAiB,CAAC,GAAG,EAAE;AAC9D,cAAM,QAAQ,KAAK,IAAI;AAEvB,YAAI,QAAQ,OAAO,MAAM;AACvB,sBAAY,MAAgB;AAAA,QAC9B;AAEA,YAAI,eAAe;AACjB,0BAAgB;AAAA,QAClB,OAAO;AACL,mBAAS,QAAQ;AAAA,QACnB;AAEA,YAAI,mBAAmB;AACrB,mBAAS,QAAQ,OAAO,IAAI;AAAA,QAC9B,OAAO;AACL,mBAAS,QAAQ;AAAA,QACnB;AAEA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,GAAG,CAAC,EAAE,KAAK,MAAM,IAAI;AACvB;AAAA,IACF;AAEA,aAAQ,cAAG,CAAC,MAAJ,YAAS,GAAG,CAAC,MAAb,YAAkB,GAAG,CAAC,GAAG;AAAA;AAAA,MAE/B,KAAK,KAAK;AACR,YAAI,YAAY;AAChB,aAAK,IAAI,KAAK,GAAG,CAAC,CAAC;AAEnB,YAAI,MAAM,MAAM;AACd,gBAAM,WAAU,cAAG,CAAC,MAAJ,mBAAO,WAAP,YAAiB,KAAK;AAEtC,cAAI,QAAQ,OAAO,QAAQ,cAAc,MAAM;AAC7C,wBAAY,MAAM;AAClB,yBAAa;AAAA,UACf;AAEA,gBAAM,QAAQ,MAAM,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAEvC,mBAAS,KAAK,GAAG,CAAC;AAElB,cAAI,WAAW,GAAG;AAChB,gBAAI,GAAG,CAAC,KAAK,KAAK;AAChB,uBAAS,OAAO;AAAA,YAClB,WAAW,GAAG,CAAC,MAAM,KAAK;AACxB,uBAAS,OAAO;AAAA,YAClB,WAAW,GAAG,CAAC,KAAK,MAAM;AACxB,uBAAS,OAAO;AAAA,YAClB,OAAO;AACL,uBAAS,OAAO;AAChB,sBAAQ,KAAK,SAAS;AAAA,YACxB;AAAA,UACF;AAEA;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA;AAAA,MAEL,KAAK,MAAM;AACT,iBAAS,YAAY;AAErB,eAAK,QAAG,CAAC,MAAJ,YAAS,GAAG,CAAC,KAAK,QAClB,OACA,SAAS,KAAK,GAAG,CAAC,CAAC;AAIxB,YAAI,MAAM,MAAM;AACd,gBAAM,WAAU,cAAG,CAAC,MAAJ,mBAAO,WAAP,YAAiB,KAAK,GAChC,KAAK,GAAG,CAAC,GACT,KAAK,GAAG,CAAC,GACT,KAAK,GAAG,CAAC,MAAM,OAAO,GAAG,CAAC,MAAM;AACtC,gBAAM,KAAK,KAAK,OAAO,GAAG,CAAC;AAE3B,gBAAM,QAAQ,KAAK,IAAI,IAAI,EAAE;AAE7B,cACE,QAAQ,OAAO,QACf,QAAQ,SAAS,QACjB;AACA,wBAAY,MAAM;AAAA,UACpB;AAEA,kBAAQ,SAAS;AACjB,kBAAQ,MAAM;AAEd,uBAAa;AAEb,cAAI,WAAW,KAAK,SAAS,MAAM,MAAM;AACvC,gBAAI,QAAQ,MAAM;AAChB,yBAAW;AAAA,YACb,OAAO;AACL,uBAAS,OAAO;AAChB,qBAAO;AAAA,YACT;AAAA,UACF;AAEA,cAAI,MAAM,MAAM;AACd,kBAAM,QAAQ,KAAK,EAAE;AACrB,mBAAQ,KAAK,SAAS,KAAK,EAAE,GAAI;AAC/B,kBAAI,GAAG,CAAC,MAAM,KAAK;AACjB,wBAAQ,KAAK,GAAG,CAAC;AAAA,cACnB,WAAW,GAAG,CAAC,MAAM,KAAK;AACxB,oBAAI,QAAQ,SAAS,MAAM;AACzB,0BAAQ,QAAQ,GAAG,CAAC;AAAA,gBACtB,OAAO;AACL,0BAAQ,SAAS,MAAM,GAAG,CAAC;AAAA,gBAC7B;AAAA,cACF,OAAO;AACL,oBAAI,GAAG,CAAC,MAAM,MAAM;AAClB,sBAAI,QAAQ,MAAM,MAAM;AACtB,4BAAQ,KAAK,GAAG,CAAC;AAAA,kBACnB;AAAA,gBACF,WAAW,GAAG,CAAC,MAAM,SAAS;AAC5B,sBAAI,QAAQ,SAAS,MAAM;AACzB,4BAAQ,QAAQ,GAAG,CAAC;AAAA,kBACtB,OAAO;AACL,4BAAQ,SAAS,MAAM,GAAG,CAAC;AAAA,kBAC7B;AAAA,gBACF,OAAO;AACL,0BAAQ,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC;AAAA,gBAC7B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,cAAI,CAAC,MAAM,MAAM,MAAM;AACrB,oBAAQ,OAAO;AAAA,UACjB,WAAW,IAAI;AACb,4BAAgB;AAChB,6BAAiB;AACjB,gCAAoB,GAAG,CAAC,MAAM;AAAA,UAChC;AAEA;AAAA,QACF;AAEA,mBAAW,YAAY;AACvB,aAAK,GAAG,CAAC,KAAK,OACT,OACA,WAAW,KAAK,GAAG,CAAC,CAAC;AAE1B,YAAI,MAAM,QAAQ,QAAQ,OAAO,MAAM;AACrC,gBAAM,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAEvB,cAAI,GAAG,CAAC,MAAM,MAAM;AAClB,gBAAI,QAAQ,MAAM,MAAM;AACtB,sBAAQ,KAAK,GAAG,CAAC,EAAE,KAAK;AAAA,YAC1B;AAAA,UACF,WAAW,GAAG,CAAC,MAAM,SAAS;AAC5B,gBAAI,QAAQ,SAAS,MAAM;AACzB,sBAAQ,SAAS,MAAM,GAAG,CAAC,EAAE,KAAK;AAAA,YACpC,OAAO;AACL,sBAAQ,QAAQ,GAAG,CAAC,EAAE,KAAK;AAAA,YAC7B;AAAA,UACF,WAAW,QAAQ,MAAM,GAAG,CAAC,CAAC,KAAK,MAAM;AACvC,oBAAQ,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC;AAAA,UAC9B,OAAO;AACL,oBAAQ,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC;AAAA,UAC7B;AAEA;AAAA,QACF;AAEA,mBAAW,YAAY;AACvB,aAAK,GAAG,CAAC,KAAK,OACR,OACA,WAAW,KAAK,GAAG,CAAC,CAAC;AAE3B,YAAI,MAAM,MAAM;AACd,gBAAM,WAAU,cAAG,CAAC,MAAJ,mBAAO,WAAP,YAAiB,KAAK;AAEtC,cAAI,QAAQ,OAAO,QAAQ,cAAc,MAAM;AAC7C,wBAAY,MAAM;AAAA,UACpB;AAEA,gBAAM,QAAQ,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;AAE/B,kBAAQ,GAAG,CAAC,GAAG;AAAA,YACb,KAAK,WAAW;AACd,uBAAS,QAAQ,cAAa,QAAG,CAAC,MAAJ,YAAS,MAAM;AAC7C;AAAA,YACF;AAAA,YACA,KAAK,OAAO;AACV,uBAAS,QAAQ,UAAS,QAAG,CAAC,MAAJ,YAAS,gCAAgC;AACnE;AAAA,YACF;AAAA,YACA,KAAK,YAAY;AACf,kBAAI,WAAW;AACf,uBAAS,WAAW,WAAW;AAE/B,8BAAgB,YAAY,YAAY;AACxC,qBAAQ,KAAK,gBAAgB,KAAK,GAAG,GAAI;AACvC,oBAAI,GAAG,CAAC,KAAK,QAAQ,CAAC,YAAY,SAAS,MAAM,MAAM;AACrD,sBAAI,YAAY;AAChB,uBAAK,IAAI,KAAK,GAAG,CAAC,CAAC;AAEnB,sBAAI,MAAM,KAAM,UAAS,KAAK,GAAG,CAAC;AAElC,2BAAS,QAAQ,GAAG,CAAC;AAAA,gBACvB,WAAW,GAAG,CAAC,KAAK,QAAQ,UAAU;AACpC,8BAAY,YAAY,gBAAgB,YAAY,GAAG,CAAC,EAAE;AAC1D;AAAA,gBACF,OAAO;AACL,2BAAS,QAAQ,OAAO,GAAG,CAAC;AAC5B,sBAAI,GAAG,CAAC,KAAK,KAAM,YAAW;AAAA,gBAChC;AAAA,cACF;AAEA,0BAAY,CAAC;AAAA,YACf;AAAA,UACF;AAEA;AAAA,QACF;AAAA,MAEF;AAAA,MACA,SAAS;AACP,aAAK,MAAM,KAAK,GAAG,CAAC,CAAC;AAErB,YAAI,MAAM,MAAM;AACd;AAAA,QACF;AACA,cAAM,SAAS,GAAG,CAAC,EAAE,SAAS;AAC9B,cAAM,KAAK,GAAG,CAAC,EAAE,KAAK;AAEtB,cAAM,QAAQ,KAAK,GAAG,CAAC,CAAC;AAExB,YAAI,QAAQ,OAAO,MAAM;AACvB,sBAAY,MAAM;AAElB,mBAAS,QAAQ;AAAA,QACnB,WAAW,SAAS,SAAS,UAAU,SAAS,SAAS,IAAI;AAC3D,mBAAS,QAAQ;AAAA,QACnB,OAAO;AACL,mBAAS,QAAQ,MAAM;AAAA,QACzB;AAEA,qBAAa;AAEb,eAAQ,KAAK,MAAM,KAAK,EAAE,GAAI;AAC5B,gBAAM,QAAQ,SAAS,KAAK,SAAS,GAAG,QAAQ,GAAG;AAEnD,mBAAS,KAAK,KAAK;AAAA,YACjB,IAAI,GAAG,CAAC;AAAA,YACR;AAAA,YACA,KAAK,QAAQ,GAAG,CAAC,EAAE;AAAA,UACrB,CAAC;AAAA,QACH;AAEA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,cAAY,CAAC;AAEb,QAAM,MAAM,MAAM,KAAK,OAAO,OAAO,CAAC;AAEtC,WAAS,QAAQC,WAA4C;AAG3D,aAAS,IAAIA,UAAS,KAAK,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,YAAM,MAAMA,UAAS,KAAK,CAAC;AAE3B,UAAI,QAAQ,IAAI,IAAI,EAAE,KAAK,CAAC,OAAO,IAAI,IAAI,EAAE,GAAG;AAC9C,QAAAA,UAAS,OAAOA,UAAS,KAAK,MAAM,GAAG,IAAI,KAAK,IAC5CA,UAAS,KAAK,MAAM,IAAI,GAAG;AAAA,MACjC,OAAO;AACL,cAAM,QAAQ,QAAQ,OAAO,IAAI,IAAI,EAAE,CAAC;AAExC,QAAAA,UAAS,OAAOA,UAAS,KAAK,MAAM,GAAG,IAAI,KAAK,IAC5C,MAAM,OACNA,UAAS,KAAK,MAAM,IAAI,GAAG;AAE/B,YAAI,MAAM,SAAS,SAAS;AAC1B,kBAAQ,IAAI,MAAM,EAAE;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAEA,IAAAA,UAAS,OAAO,CAAC;AAEjB,WAAOA;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,OAAO,OAAO,GAAG,KAAK;AACxC,QAAIA;AAEJ,QAAI,MAAM,KAAK,QAAQ,MAAM;AAC3B;AAAA,IACF,WAAW,MAAM,GAAG;AAClB,MAAAA,YAAW;AAAA,IACb,OAAO;AACL,MAAAA,YAAW,IAAI,IAAI,CAAC;AAAA,IACtB;AAEA,QAAIA,UAAS,KAAK,WAAW,GAAG;AAC9B;AAAA,IACF;AAEA,YAAQA,SAAQ;AAAA,EAClB;AAEA,OAAI,6BAAM,SAAQ,MAAM;AACtB,WAAO,OAAO,KAAK;AACnB,WAAO,WAAW;AAAA,EACpB;AAEA,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,QAAI;AACJ,UAAMA,YAAW,IAAI,CAAC;AAEtB,QAAIA,aAAY,QAAQ,QAAQ,IAAIA,UAAS,EAAE,GAAG;AAChD;AAAA,IACF;AAEA,QAAIA,UAAS,SAAS,SAAS;AAC7B,iBAAW,OAAOA,UAAS,EAAE;AAAA,IAC/B,WAAWA,UAAS,SAAS,QAAQ;AACnC,iBAAW,YAAYA,UAAS,EAAE;AAAA,IACpC,WAAWA,UAAS,SAAS,SAAS;AACpC,iBAAW,YAAYA,UAAS,EAAE;AAAA,IACpC;AAEA,WAAO,UAAUA,UAAS,EAAE,IAAI;AAAA,MAC9B,IAAIA,UAAS;AAAA,MACb;AAAA,MACA,MAAMA,UAAS;AAAA,MACf,MAAMA,UAAS;AAAA,IACjB;AAAA,EACF;AAEA,SAAO;AACT;AAGA,MAAM,aAAa;AAUZ,gBAAS,gBACd,UACA,MACA,aACoB;AA1jBtB;AA2jBE,QAAM,KAAK,SAAS,QAAQ,YAAY,CAAC,QAAQ,OAAO,QAAQ;AAC9D,QAAI,OAAO,MAAM;AACf,YAAM,WAAW,YAAY,GAAG;AAEhC,UAAI,YAAY,KAAM,QAAO;AAE7B,aAAO;AAAA,IACT;AAEA,WAAO,KAAK,KAAK,KAAK,OAAO,OAAO,KAAK,KAAK,EAAE,SAAS,CAAC,IAAI;AAAA,EAChE,CAAC;AAED,UAAO,kBAAO,OAAO,SAAS,EAAE,EAAE,SAAS,EAAE,CAAC,MAAvC,mBAA0C,SAA1C,YAAkD;AAC3D;",
  "names": ["root", "element", "fragment"]
}
