{
  "version": 3,
  "sources": ["../lib/longform.ts"],
  "sourcesContent": ["import type { WorkingElement, WorkingChunk, ChunkType, WorkingFragment, FragmentType, ParsedResult } from \"./types.ts\";\r\n// exported for generated d.ts file to include types.\r\nexport * from './types.ts';\r\n\r\nconst sniffTestRe = /^(?:(?:(--).*)|(?: *(@|#).*)|(?: *[\\w\\-]+(?::[\\w\\-]+)?(?:[#.[][^\\n]+)?(::).*)|(?:  +(\\[).*)|(\\ \\ .*))$/gmi\r\n  , element1 = /((?:\\ \\ )+)? ?([\\w\\-]+(?::[\\w\\-]+)?)([#\\.\\[][^\\n]*)?::(?: ({{?|[^\\n]+))?/gmi\r\n  , directive1 = /((?:\\ \\ )+)? ?@([\\w][\\w\\-]+)(?::: ?([^\\n]+)?)?/gmi\r\n  , attribute1 = /((?:\\ \\ )+)\\[(\\w[\\w-]*(?::\\w[\\w-]*)?)(?:=([^\\n]+))?\\]/\r\n  , preformattedClose = /[ \\t]*}}?[ \\t]*/\r\n  , id1 = /((?:\\ \\ )+)?#(#)?([\\w\\-]+)( \\[)?/gmi\r\n  , idnt1 = /^(\\ \\ )+/\r\n  , text1 = /^((?:\\ \\ )+)([^ \\n][^\\n]*)$/i\r\n  , paramsRe = /(?:(#|\\.)([^#.\\[\\n]+)|(?:\\[(\\w[\\w\\-]*(?::\\w[\\w\\-]*)?)(?:=([^\\n\\]]+))?\\]))/g\r\n  , refRe = /#\\[([\\w\\-]+)\\]/g\r\n  , voids = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wrb']);\r\n\r\nlet m1: RegExpExecArray | null\r\n  , m2: RegExpExecArray | null;\r\n\r\n\r\nfunction makeElement(indent: number = 0): WorkingElement {\r\n  return {\r\n    indent,\r\n    html: '',\r\n    attrs: {},\r\n  };\r\n}\r\n\r\nfunction makeChunk(type: ChunkType = 'parsed'): WorkingChunk {\r\n  return {\r\n    type,\r\n    html: '',\r\n    els: [],\r\n  };\r\n}\r\n\r\nfunction makeFragment(type: FragmentType = 'bare'): WorkingFragment {\r\n  return {\r\n    type,\r\n    html: '',\r\n    els: [],\r\n    chunks: [],\r\n    refs: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Parses a longform document into a object containing the root and fragments\r\n * in the output format.\r\n *\r\n * @param {string} doc - The longform document to parse.\r\n * @returns {ParsedResult}\r\n */\r\nexport function longform(doc: string, debug: (...d: unknown[]) => void = () => {}): ParsedResult {\r\n  let skipping: boolean = false\r\n    , textIndent: number | null = null\r\n    , verbatimSerialize: boolean = true\r\n    , verbatimIndent: number | null = null\r\n    , verbatimFirst: boolean = false\r\n    , element: WorkingElement = makeElement()\r\n    , chunk: WorkingChunk | null = makeChunk()\r\n    , fragment: WorkingFragment = makeFragment()\r\n    // the root fragment\r\n    , root: WorkingFragment | null = null\r\n    // ids of claimed fragments\r\n  const claimed: Set<string> = new Set()\r\n    // parsed fragments\r\n    , parsed: Map<string, WorkingFragment> = new Map()\r\n    , output: ParsedResult = Object.create(null);\r\n\r\n  output.fragments = Object.create(null);\r\n  \r\n  \r\n  /**\r\n   * Closes any current in progress element definition\r\n   * and creates a new working element.\r\n   */\r\n  function applyIndent(targetIndent: number) {\r\n    if (element.tag != null) {\r\n      const root = fragment.type === 'range'\r\n        ? targetIndent < 2\r\n        : fragment.html === ''\r\n      ;\r\n\r\n      fragment.html += `<${element.tag}`\r\n\r\n      if (root) {\r\n        if (fragment.type === 'root') {\r\n          fragment.html += ` data-lf-root`;\r\n        } else if (fragment.type === 'bare' || fragment.type === 'range') {\r\n          fragment.html += ` data-lf=\"${fragment.id}\"`;\r\n        }\r\n      }\r\n\r\n      if (element.id != null) {\r\n        fragment.html += ' id=\"' + element.id + '\"';\r\n      }\r\n\r\n      if (element.class != null) {\r\n        fragment.html += ' class=\"' + element.class + '\"';\r\n      }\r\n\r\n      for (const attr of Object.entries(element.attrs)) {\r\n        if (attr[1] == null) {\r\n          fragment.html += ' ' + attr[0]\r\n        } else {\r\n          fragment.html += ` ${attr[0]}=\"${attr[1]}\"`;\r\n        }\r\n      }\r\n\r\n      fragment.html += '>';\r\n\r\n      if (!voids.has(element.tag as string) && element.text != null) {\r\n        fragment.html += element.text;\r\n      }\r\n\r\n      if (\r\n        !voids.has(element.tag as string)\r\n      ) {\r\n        fragment.els.push(element);\r\n      }\r\n    }\r\n\r\n    if (targetIndent <= element.indent) {\r\n      element = makeElement(targetIndent);\r\n\r\n      while (\r\n        fragment.els.length !== 0 && (\r\n          targetIndent == null ||\r\n          fragment.els[fragment.els.length - 1].indent !== targetIndent - 1\r\n        )\r\n      ) {\r\n        const element = fragment.els.pop();\r\n\r\n        fragment.html += `</${element?.tag}>`;\r\n      }\r\n\r\n      if (targetIndent === 0) {\r\n        debug(0, '<', fragment.type, fragment.id);\r\n        if (fragment.type === 'root') {\r\n          root = fragment;\r\n        } else {\r\n          parsed.set(fragment.id, fragment);\r\n        }\r\n\r\n        fragment = makeFragment();\r\n      }\r\n    } else {\r\n      element = makeElement(targetIndent)\r\n    }\r\n  }\r\n\r\n  while ((m1 = sniffTestRe.exec(doc))) {\r\n    if (m1[1] === '--') {\r\n      continue;\r\n    }\r\n\r\n    // If this is a script tag or preformatted block\r\n    // we want to retain the intended formatting less\r\n    // the indent. Preformatting can apply to any element\r\n    // by ending the declaration with `:: {`.\r\n    if (verbatimIndent != null) {\r\n      // inside a script or preformatted block\r\n      idnt1.lastIndex = 0;\r\n      m2 = idnt1.exec(m1[0]);\r\n      const indent = m2 == null\r\n        ? null\r\n        : m2[0].length / 2;\r\n\r\n      if (m2 == null || indent as number <= verbatimIndent) {\r\n        fragment.html += '\\n';\r\n        debug(indent, '}', m2?.[0]);\r\n\r\n        applyIndent(indent);\r\n        verbatimIndent = null;\r\n        verbatimFirst = false;\r\n        textIndent = indent;\r\n\r\n        if (preformattedClose.test(m1[0])) {\r\n          continue;\r\n        }\r\n      } else {\r\n        const line = m1[0].replace('  '.repeat(verbatimIndent + 1), '');\r\n        debug(indent, '{', line);\r\n\r\n        if (element.tag != null) {\r\n          applyIndent(indent as number);\r\n        }\r\n\r\n        if (verbatimFirst) {\r\n          verbatimFirst = false;\r\n        } else {\r\n          fragment.html += '\\n';\r\n        }\r\n        \r\n        if (verbatimSerialize) {\r\n          fragment.html += line\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#039;');\r\n        } else {\r\n          fragment.html += line;\r\n        }\r\n\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (m1[0].trim() === '') {\r\n      continue;\r\n    }\r\n\r\n    switch (m1[2] ?? m1[3] ?? m1[4]) {\r\n      // deno-lint-ignore no-fallthrough\r\n      case '#': {\r\n        id1.lastIndex = 0;\r\n        m2 = id1.exec(m1[0]);\r\n\r\n        if (m2 != null) {\r\n          const indent = (m2[1]?.length ?? 0) / 2;\r\n\r\n          if (element.tag != null || textIndent != null) {\r\n            applyIndent(indent);\r\n            textIndent = null;\r\n          }\r\n\r\n          debug(indent, 'id', m2[2], m2[3], m2[4]);\r\n\r\n          fragment.id = m2[3];\r\n\r\n          if (indent === 0) {\r\n            if (m2[4] != null) {\r\n              fragment.type = 'range';\r\n            } else if (m2[2] != null) {\r\n              fragment.type = 'bare';\r\n            } else {\r\n              fragment.type = 'embed';\r\n              element.id = fragment.id;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n      case '@':\r\n      case '[':\r\n      // deno-lint-ignore no-fallthrough\r\n      case '::': {\r\n        element1.lastIndex = 0;\r\n        // fall through if m1[3] is a # or @\r\n        m2 = m1[2] ?? m1[4] != null\r\n           ? null\r\n           : element1.exec(m1[0]);\r\n\r\n        // if null then invalid element selector\r\n        // allow the default text case to handle\r\n        if (m2 != null) {\r\n          const indent = (m2[1]?.length ?? 0) / 2\r\n              , tg = m2[2]\r\n              , ar = m2[3]\r\n              , pr = m2[4] === '{' || m2[4] === '{{'\r\n          const tx = pr ? null : m2[4]\r\n\r\n          debug(indent, 'e', tg, pr, tx);\r\n\r\n          if (\r\n            element.tag != null ||\r\n            element.indent > indent\r\n          ) {\r\n            applyIndent(indent);\r\n          }\r\n\r\n          element.indent = indent;\r\n          element.tag = tg;\r\n\r\n          textIndent = null;\r\n          \r\n          if (indent === 0 && fragment.id == null) {\r\n            if (root != null) {\r\n              skipping = true;\r\n            } else {\r\n              fragment.type = 'root';\r\n              root = fragment;\r\n            }\r\n          }\r\n          \r\n          if (ar != null) {\r\n            debug(indent, 'a', ar);\r\n            while ((m2 = paramsRe.exec(ar))) {\r\n              if (m2[1] === '#') {\r\n                element.id = m2[2];\r\n              } else if (m2[1] === '.') {\r\n                if (element.class == null) {\r\n                  element.class = m2[2];\r\n                } else {\r\n                  element.class += ' ' + m2[2];\r\n                }\r\n              } else {\r\n                if (m2[3] === 'id') {\r\n                  if (element.id == null) {\r\n                    element.id = m2[4];\r\n                  }\r\n                } else if (m2[3] === 'class') {\r\n                  if (element.class == null) {\r\n                    element.class = m2[4]\r\n                  } else {\r\n                    element.class += ' ' + m2[4]\r\n                  }\r\n                } else {\r\n                  element.attrs[m2[3]] = m2[4];\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!pr && tx != null) {\r\n            element.text = tx;\r\n          } else if (pr) {\r\n            verbatimFirst = true;\r\n            verbatimIndent = indent;\r\n            verbatimSerialize = m2[4] === '{';\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        attribute1.lastIndex = 0;\r\n        m2 = m1[2] != null\r\n           ? null\r\n           : attribute1.exec(m1[0]);\r\n\r\n        if (m2 != null && element.tag != null) {\r\n          debug('a', m2[2], m2[3]);\r\n\r\n          if (m2[2] === 'id') {\r\n            if (element.id == null) {\r\n              element.id = m2[3].trim();\r\n            }\r\n          } else if (m2[2] === 'class') {\r\n            if (element.class != null) {\r\n              element.class += ' ' + m2[3].trim();\r\n            } else {\r\n              element.class = m2[3].trim();\r\n            }\r\n          } else if (element.attrs[m2[2]] != null) {\r\n            element.attrs[m2[2]] += m2[3];\r\n          } else {\r\n            element.attrs[m2[2]] = m2[3];\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n        directive1.lastIndex = 0;\r\n        m2 = m1[3] != null\r\n            ? null \r\n            : directive1.exec(m1[0]);\r\n\r\n        if (m2 != null) {\r\n          const indent = (m2[1]?.length ?? 0) / 2;\r\n\r\n          if (element.tag != null || textIndent != null) {\r\n            applyIndent(indent);\r\n          }\r\n\r\n          debug(indent, 'd', m2[2], m2[3]);\r\n\r\n          switch (m2[2]) {\r\n            case 'doctype': {\r\n              fragment.html += `<!doctype ${m2[3] ?? 'html'}>`;\r\n              break;\r\n            }\r\n            case 'xml': {\r\n              fragment.html += `<?xml ${m2[3] ?? 'version=\"1.0\" encoding=\"UTF-8\"'}?>`;\r\n              break;\r\n            }\r\n          }\r\n\r\n          break;\r\n        }\r\n\r\n      }\r\n      default: {\r\n        m2 = text1.exec(m1[0]) as RegExpExecArray;\r\n\r\n        if (m2 == null) {\r\n          break;\r\n        }\r\n        const indent = m2[1].length / 2;\r\n        const tx = m2[2].trim();\r\n\r\n\r\n        debug(indent, 't', m2[2]);\r\n\r\n        if (element.tag != null) {\r\n          applyIndent(indent);\r\n\r\n          fragment.html += tx;\r\n        } else {\r\n          fragment.html += ' ' + tx;\r\n        }\r\n\r\n        textIndent = indent;\r\n\r\n        while ((m2 = refRe.exec(tx))) {\r\n          const start = fragment.html.length + m2.index - tx.length;\r\n\r\n          fragment.refs.push({\r\n            id: m2[1],\r\n            start,\r\n            end: start + m2[0].length,\r\n          });\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  applyIndent(0);\r\n\r\n  const arr = Array.from(parsed.values());\r\n\r\n  function flatten(fragment: WorkingFragment): WorkingFragment {\r\n    // work backwards so we don't change the html string length\r\n    // for the later replacements\r\n    for (let j = fragment.refs.length - 1; j >= 0; j--) {\r\n      const ref = fragment.refs[j];\r\n\r\n      if (claimed.has(ref.id) || !parsed.has(ref.id)) {\r\n        fragment.html = fragment.html.slice(0, ref.start)\r\n          + fragment.html.slice(ref.end)\r\n      } else {\r\n        const child = flatten(parsed.get(ref.id));\r\n\r\n        fragment.html = fragment.html.slice(0, ref.start)\r\n          + child.html\r\n          + fragment.html.slice(ref.end);\r\n\r\n        if (child.type === 'embed') {\r\n          claimed.add(child.id)\r\n        }\r\n      }\r\n    }\r\n\r\n    fragment.refs = [];\r\n\r\n    return fragment;\r\n  }\r\n\r\n  for (let i = 0; i < parsed.size + 1; i++) {\r\n    let fragment: WorkingFragment;\r\n    \r\n    if (i === 0 && root == null) {\r\n      continue;\r\n    } else if (i === 0) {\r\n      fragment = root;\r\n    } else {\r\n      fragment = arr[i - 1];\r\n    }\r\n\r\n    if (fragment.refs.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    flatten(fragment)\r\n  }\r\n\r\n  if (root?.html != null) {\r\n    output.root = root.html;\r\n    output.selector = `[data-lf-root]`;\r\n  }\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    let selector: string;\r\n    const fragment = arr[i];\r\n\r\n    if (fragment == null || claimed.has(fragment.id)) {\r\n      continue;\r\n    }\r\n\r\n    if (fragment.type === 'embed') {\r\n      selector = `[id=${fragment.id}]`;\r\n    } else if (fragment.type === 'bare') {\r\n      selector = `[data-lf=${fragment.id}]`;\r\n    } else if (fragment.type === 'range') {\r\n      selector = `[data-lf=${fragment.id}]`;\r\n    }\r\n\r\n    output.fragments[fragment.id] = {\r\n      id: fragment.id,\r\n      selector,\r\n      type: fragment.type as 'embed' | 'bare' | 'range',\r\n      html: fragment.html,\r\n    };\r\n  }\r\n\r\n  return output;\r\n}\r\n"],
  "mappings": "AAEA,WAAc,aAEd,MAAMA,EAAc,4GAChBC,EAAW,8EACXC,EAAa,oDACbC,EAAa,wDACbC,EAAoB,kBACpBC,EAAM,sCACNC,EAAQ,WACRC,EAAQ,+BACRC,EAAW,6EACXC,EAAQ,kBACRC,EAAQ,IAAI,IAAI,CAAC,OAAQ,OAAQ,KAAM,MAAO,QAAS,KAAM,MAAO,QAAS,OAAQ,OAAQ,QAAS,SAAU,QAAS,KAAK,CAAC,EAEnI,IAAIC,EACAC,EAGJ,SAASC,EAAYC,EAAiB,EAAmB,CACvD,MAAO,CACL,OAAAA,EACA,KAAM,GACN,MAAO,CAAC,CACV,CACF,CAEA,SAASC,EAAUC,EAAkB,SAAwB,CAC3D,MAAO,CACL,KAAAA,EACA,KAAM,GACN,IAAK,CAAC,CACR,CACF,CAEA,SAASC,EAAaD,EAAqB,OAAyB,CAClE,MAAO,CACL,KAAAA,EACA,KAAM,GACN,IAAK,CAAC,EACN,OAAQ,CAAC,EACT,KAAM,CAAC,CACT,CACF,CASO,gBAAS,SAASE,EAAaC,EAAmC,IAAM,CAAC,EAAiB,CArDjG,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAsDE,IAAIC,EAAoB,GACpBC,EAA4B,KAC5BC,EAA6B,GAC7BC,EAAgC,KAChCC,EAAyB,GACzBC,EAA0BvB,EAAY,EACtCwB,EAA6BtB,EAAU,EACvCuB,EAA4BrB,EAAa,EAEzCsB,EAA+B,KAEnC,MAAMC,EAAuB,IAAI,IAE7BC,EAAuC,IAAI,IAC3CC,EAAuB,OAAO,OAAO,IAAI,EAE7CA,EAAO,UAAY,OAAO,OAAO,IAAI,EAOrC,SAASC,EAAYC,EAAsB,CACzC,GAAIR,EAAQ,KAAO,KAAM,CACvB,MAAMG,EAAOD,EAAS,OAAS,QAC3BM,EAAe,EACfN,EAAS,OAAS,GAGtBA,EAAS,MAAQ,IAAIF,EAAQ,GAAG,GAE5BG,IACED,EAAS,OAAS,OACpBA,EAAS,MAAQ,iBACRA,EAAS,OAAS,QAAUA,EAAS,OAAS,WACvDA,EAAS,MAAQ,aAAaA,EAAS,EAAE,MAIzCF,EAAQ,IAAM,OAChBE,EAAS,MAAQ,QAAUF,EAAQ,GAAK,KAGtCA,EAAQ,OAAS,OACnBE,EAAS,MAAQ,WAAaF,EAAQ,MAAQ,KAGhD,UAAWS,KAAQ,OAAO,QAAQT,EAAQ,KAAK,EACzCS,EAAK,CAAC,GAAK,KACbP,EAAS,MAAQ,IAAMO,EAAK,CAAC,EAE7BP,EAAS,MAAQ,IAAIO,EAAK,CAAC,CAAC,KAAKA,EAAK,CAAC,CAAC,IAI5CP,EAAS,MAAQ,IAEb,CAAC5B,EAAM,IAAI0B,EAAQ,GAAa,GAAKA,EAAQ,MAAQ,OACvDE,EAAS,MAAQF,EAAQ,MAIxB1B,EAAM,IAAI0B,EAAQ,GAAa,GAEhCE,EAAS,IAAI,KAAKF,CAAO,CAE7B,CAEA,GAAIQ,GAAgBR,EAAQ,OAAQ,CAGlC,IAFAA,EAAUvB,EAAY+B,CAAY,EAGhCN,EAAS,IAAI,SAAW,IACtBM,GAAgB,MAChBN,EAAS,IAAIA,EAAS,IAAI,OAAS,CAAC,EAAE,SAAWM,EAAe,IAElE,CACA,MAAMR,EAAUE,EAAS,IAAI,IAAI,EAEjCA,EAAS,MAAQ,KAAKF,GAAA,YAAAA,EAAS,GAAG,GACpC,CAEIQ,IAAiB,IACnBzB,EAAM,EAAG,IAAKmB,EAAS,KAAMA,EAAS,EAAE,EACpCA,EAAS,OAAS,OACpBC,EAAOD,EAEPG,EAAO,IAAIH,EAAS,GAAIA,CAAQ,EAGlCA,EAAWrB,EAAa,EAE5B,MACEmB,EAAUvB,EAAY+B,CAAY,CAEtC,CAEA,KAAQjC,EAAKX,EAAY,KAAKkB,CAAG,GAC/B,GAAIP,EAAG,CAAC,IAAM,KAQd,IAAIuB,GAAkB,KAAM,CAE1B5B,EAAM,UAAY,EAClBM,EAAKN,EAAM,KAAKK,EAAG,CAAC,CAAC,EACrB,MAAMG,EAASF,GAAM,KACjB,KACAA,EAAG,CAAC,EAAE,OAAS,EAEnB,GAAIA,GAAM,MAAQE,GAAoBoB,GASpC,GARAI,EAAS,MAAQ;AAAA,EACjBnB,EAAML,EAAQ,IAAKF,GAAA,YAAAA,EAAK,EAAE,EAE1B+B,EAAY7B,CAAM,EAClBoB,EAAiB,KACjBC,EAAgB,GAChBH,EAAalB,EAETV,EAAkB,KAAKO,EAAG,CAAC,CAAC,EAC9B,aAEG,CACL,MAAMmC,EAAOnC,EAAG,CAAC,EAAE,QAAQ,KAAK,OAAOuB,EAAiB,CAAC,EAAG,EAAE,EAC9Df,EAAML,EAAQ,IAAKgC,CAAI,EAEnBV,EAAQ,KAAO,MACjBO,EAAY7B,CAAgB,EAG1BqB,EACFA,EAAgB,GAEhBG,EAAS,MAAQ;AAAA,EAGfL,EACFK,EAAS,MAAQQ,EACd,QAAQ,KAAM,OAAO,EACrB,QAAQ,KAAM,MAAM,EACpB,QAAQ,KAAM,MAAM,EACpB,QAAQ,KAAM,QAAQ,EACtB,QAAQ,KAAM,QAAQ,EAEzBR,EAAS,MAAQQ,EAGnB,QACF,CACF,CAEA,GAAInC,EAAG,CAAC,EAAE,KAAK,IAAM,GAIrB,QAAQU,GAAAD,EAAAT,EAAG,CAAC,IAAJ,KAAAS,EAAST,EAAG,CAAC,IAAb,KAAAU,EAAkBV,EAAG,CAAC,EAAG,CAE/B,IAAK,IAIH,GAHAN,EAAI,UAAY,EAChBO,EAAKP,EAAI,KAAKM,EAAG,CAAC,CAAC,EAEfC,GAAM,KAAM,CACd,MAAME,IAAUS,GAAAD,EAAAV,EAAG,CAAC,IAAJ,YAAAU,EAAO,SAAP,KAAAC,EAAiB,GAAK,GAElCa,EAAQ,KAAO,MAAQJ,GAAc,QACvCW,EAAY7B,CAAM,EAClBkB,EAAa,MAGfb,EAAML,EAAQ,KAAMF,EAAG,CAAC,EAAGA,EAAG,CAAC,EAAGA,EAAG,CAAC,CAAC,EAEvC0B,EAAS,GAAK1B,EAAG,CAAC,EAEdE,IAAW,IACTF,EAAG,CAAC,GAAK,KACX0B,EAAS,KAAO,QACP1B,EAAG,CAAC,GAAK,KAClB0B,EAAS,KAAO,QAEhBA,EAAS,KAAO,QAChBF,EAAQ,GAAKE,EAAS,KAI1B,KACF,CAEF,IAAK,IACL,IAAK,IAEL,IAAK,KAAM,CAST,GARArC,EAAS,UAAY,EAErBW,IAAKY,EAAAb,EAAG,CAAC,IAAJ,KAAAa,EAASb,EAAG,CAAC,GAAK,MAClB,KACAV,EAAS,KAAKU,EAAG,CAAC,CAAC,EAIpBC,GAAM,KAAM,CACd,MAAME,IAAUY,GAAAD,EAAAb,EAAG,CAAC,IAAJ,YAAAa,EAAO,SAAP,KAAAC,EAAiB,GAAK,EAChCqB,EAAKnC,EAAG,CAAC,EACToC,EAAKpC,EAAG,CAAC,EACTqC,EAAKrC,EAAG,CAAC,IAAM,KAAOA,EAAG,CAAC,IAAM,KAChCsC,EAAKD,EAAK,KAAOrC,EAAG,CAAC,EAyB3B,GAvBAO,EAAML,EAAQ,IAAKiC,EAAIE,EAAIC,CAAE,GAG3Bd,EAAQ,KAAO,MACfA,EAAQ,OAAStB,IAEjB6B,EAAY7B,CAAM,EAGpBsB,EAAQ,OAAStB,EACjBsB,EAAQ,IAAMW,EAEdf,EAAa,KAETlB,IAAW,GAAKwB,EAAS,IAAM,OAC7BC,GAAQ,KACVR,EAAW,IAEXO,EAAS,KAAO,OAChBC,EAAOD,IAIPU,GAAM,KAER,IADA7B,EAAML,EAAQ,IAAKkC,CAAE,EACbpC,EAAKJ,EAAS,KAAKwC,CAAE,GACvBpC,EAAG,CAAC,IAAM,IACZwB,EAAQ,GAAKxB,EAAG,CAAC,EACRA,EAAG,CAAC,IAAM,IACfwB,EAAQ,OAAS,KACnBA,EAAQ,MAAQxB,EAAG,CAAC,EAEpBwB,EAAQ,OAAS,IAAMxB,EAAG,CAAC,EAGzBA,EAAG,CAAC,IAAM,KACRwB,EAAQ,IAAM,OAChBA,EAAQ,GAAKxB,EAAG,CAAC,GAEVA,EAAG,CAAC,IAAM,QACfwB,EAAQ,OAAS,KACnBA,EAAQ,MAAQxB,EAAG,CAAC,EAEpBwB,EAAQ,OAAS,IAAMxB,EAAG,CAAC,EAG7BwB,EAAQ,MAAMxB,EAAG,CAAC,CAAC,EAAIA,EAAG,CAAC,EAM/B,CAACqC,GAAMC,GAAM,KACfd,EAAQ,KAAOc,EACND,IACTd,EAAgB,GAChBD,EAAiBpB,EACjBmB,EAAoBrB,EAAG,CAAC,IAAM,KAGhC,KACF,CAOA,GALAT,EAAW,UAAY,EACvBS,EAAKD,EAAG,CAAC,GAAK,KACT,KACAR,EAAW,KAAKQ,EAAG,CAAC,CAAC,EAEtBC,GAAM,MAAQwB,EAAQ,KAAO,KAAM,CACrCjB,EAAM,IAAKP,EAAG,CAAC,EAAGA,EAAG,CAAC,CAAC,EAEnBA,EAAG,CAAC,IAAM,KACRwB,EAAQ,IAAM,OAChBA,EAAQ,GAAKxB,EAAG,CAAC,EAAE,KAAK,GAEjBA,EAAG,CAAC,IAAM,QACfwB,EAAQ,OAAS,KACnBA,EAAQ,OAAS,IAAMxB,EAAG,CAAC,EAAE,KAAK,EAElCwB,EAAQ,MAAQxB,EAAG,CAAC,EAAE,KAAK,EAEpBwB,EAAQ,MAAMxB,EAAG,CAAC,CAAC,GAAK,KACjCwB,EAAQ,MAAMxB,EAAG,CAAC,CAAC,GAAKA,EAAG,CAAC,EAE5BwB,EAAQ,MAAMxB,EAAG,CAAC,CAAC,EAAIA,EAAG,CAAC,EAG7B,KACF,CAOA,GALAV,EAAW,UAAY,EACvBU,EAAKD,EAAG,CAAC,GAAK,KACR,KACAT,EAAW,KAAKS,EAAG,CAAC,CAAC,EAEvBC,GAAM,KAAM,CACd,MAAME,IAAUc,GAAAD,EAAAf,EAAG,CAAC,IAAJ,YAAAe,EAAO,SAAP,KAAAC,EAAiB,GAAK,EAQtC,QANIQ,EAAQ,KAAO,MAAQJ,GAAc,OACvCW,EAAY7B,CAAM,EAGpBK,EAAML,EAAQ,IAAKF,EAAG,CAAC,EAAGA,EAAG,CAAC,CAAC,EAEvBA,EAAG,CAAC,EAAG,CACb,IAAK,UAAW,CACd0B,EAAS,MAAQ,cAAaT,EAAAjB,EAAG,CAAC,IAAJ,KAAAiB,EAAS,MAAM,IAC7C,KACF,CACA,IAAK,MAAO,CACVS,EAAS,MAAQ,UAASR,EAAAlB,EAAG,CAAC,IAAJ,KAAAkB,EAAS,gCAAgC,KACnE,KACF,CACF,CAEA,KACF,CAEF,CACA,QAAS,CAGP,GAFAlB,EAAKL,EAAM,KAAKI,EAAG,CAAC,CAAC,EAEjBC,GAAM,KACR,MAEF,MAAME,EAASF,EAAG,CAAC,EAAE,OAAS,EACxBsC,EAAKtC,EAAG,CAAC,EAAE,KAAK,EAetB,IAZAO,EAAML,EAAQ,IAAKF,EAAG,CAAC,CAAC,EAEpBwB,EAAQ,KAAO,MACjBO,EAAY7B,CAAM,EAElBwB,EAAS,MAAQY,GAEjBZ,EAAS,MAAQ,IAAMY,EAGzBlB,EAAalB,EAELF,EAAKH,EAAM,KAAKyC,CAAE,GAAI,CAC5B,MAAMC,EAAQb,EAAS,KAAK,OAAS1B,EAAG,MAAQsC,EAAG,OAEnDZ,EAAS,KAAK,KAAK,CACjB,GAAI1B,EAAG,CAAC,EACR,MAAAuC,EACA,IAAKA,EAAQvC,EAAG,CAAC,EAAE,MACrB,CAAC,CACH,CAEA,KACF,CACF,EAGF+B,EAAY,CAAC,EAEb,MAAMS,EAAM,MAAM,KAAKX,EAAO,OAAO,CAAC,EAEtC,SAASY,EAAQf,EAA4C,CAG3D,QAASgB,EAAIhB,EAAS,KAAK,OAAS,EAAGgB,GAAK,EAAGA,IAAK,CAClD,MAAMC,EAAMjB,EAAS,KAAKgB,CAAC,EAE3B,GAAId,EAAQ,IAAIe,EAAI,EAAE,GAAK,CAACd,EAAO,IAAIc,EAAI,EAAE,EAC3CjB,EAAS,KAAOA,EAAS,KAAK,MAAM,EAAGiB,EAAI,KAAK,EAC5CjB,EAAS,KAAK,MAAMiB,EAAI,GAAG,MAC1B,CACL,MAAMC,EAAQH,EAAQZ,EAAO,IAAIc,EAAI,EAAE,CAAC,EAExCjB,EAAS,KAAOA,EAAS,KAAK,MAAM,EAAGiB,EAAI,KAAK,EAC5CC,EAAM,KACNlB,EAAS,KAAK,MAAMiB,EAAI,GAAG,EAE3BC,EAAM,OAAS,SACjBhB,EAAQ,IAAIgB,EAAM,EAAE,CAExB,CACF,CAEA,OAAAlB,EAAS,KAAO,CAAC,EAEVA,CACT,CAEA,QAASmB,EAAI,EAAGA,EAAIhB,EAAO,KAAO,EAAGgB,IAAK,CACxC,IAAInB,EAEAmB,IAAM,GAAKlB,GAAQ,OAEZkB,IAAM,EACfnB,EAAWC,EAEXD,EAAWc,EAAIK,EAAI,CAAC,EAGlBnB,EAAS,KAAK,SAAW,GAI7Be,EAAQf,CAAQ,EAClB,EAEIC,GAAA,YAAAA,EAAM,OAAQ,OAChBG,EAAO,KAAOH,EAAK,KACnBG,EAAO,SAAW,kBAGpB,QAASe,EAAI,EAAGA,EAAIL,EAAI,OAAQK,IAAK,CACnC,IAAIC,EACJ,MAAMpB,EAAWc,EAAIK,CAAC,EAElBnB,GAAY,MAAQE,EAAQ,IAAIF,EAAS,EAAE,IAI3CA,EAAS,OAAS,QACpBoB,EAAW,OAAOpB,EAAS,EAAE,IACpBA,EAAS,OAAS,OAC3BoB,EAAW,YAAYpB,EAAS,EAAE,IACzBA,EAAS,OAAS,UAC3BoB,EAAW,YAAYpB,EAAS,EAAE,KAGpCI,EAAO,UAAUJ,EAAS,EAAE,EAAI,CAC9B,GAAIA,EAAS,GACb,SAAAoB,EACA,KAAMpB,EAAS,KACf,KAAMA,EAAS,IACjB,EACF,CAEA,OAAOI,CACT",
  "names": ["sniffTestRe", "element1", "directive1", "attribute1", "preformattedClose", "id1", "idnt1", "text1", "paramsRe", "refRe", "voids", "m1", "m2", "makeElement", "indent", "makeChunk", "type", "makeFragment", "doc", "debug", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "skipping", "textIndent", "verbatimSerialize", "verbatimIndent", "verbatimFirst", "element", "chunk", "fragment", "root", "claimed", "parsed", "output", "applyIndent", "targetIndent", "attr", "line", "tg", "ar", "pr", "tx", "start", "arr", "flatten", "j", "ref", "child", "i", "selector"]
}
