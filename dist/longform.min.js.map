{
  "version": 3,
  "sources": ["../lib/longform.ts"],
  "sourcesContent": ["import type { FragmentType, ParsedResult, WorkingElement, WorkingFragment, Fragment } from \"./types.ts\";\n\nexport type {\n  FragmentType,\n  Fragment,\n  ParsedResult\n};\n\nconst sniffTestRe = /^(?:(?:(--).*)|(?: *(@|#).*)|(?: *[\\w\\-]+(?::[\\w\\-]+)?(?:[#.[][^\\n]+)?(::).*)|(?:  +([\\[\"]).*)|(\\ \\ .*))$/gmi\n  , element1 = /((?:\\ \\ )+)? ?([\\w\\-]+(?::[\\w\\-]+)?)([#\\.\\[][^\\n]*)?::(?: ({{?|[^\\n]+))?/gmi\n  , directive1 = /((?:\\ \\ )+)? ?@([\\w][\\w\\-]+)(?::: ?([^\\n]+)?)?/gmi\n  , attribute1 = /((?:\\ \\ )+)\\[(\\w[\\w-]*(?::\\w[\\w-]*)?)(?:=([^\\n]+))?\\]/\n  , preformattedClose = /[ \\t]*}}?[ \\t]*/\n  , id1 = /((?:\\ \\ )+)?#(#)?([\\w\\-]+)(?: ([\\[\"]))?/gmi\n  , idnt1 = /^(\\ \\ )+/\n  , text1 = /^((?:\\ \\ )+)([^ \\n][^\\n]*)$/i\n  , paramsRe = /(?:(#|\\.)([^#.\\[\\n]+)|(?:\\[(\\w[\\w\\-]*(?::\\w[\\w\\-]*)?)(?:=([^\\n\\]]+))?\\]))/g\n  , refRe = /#\\[([\\w\\-]+)\\]/g\n  , escapeRe = /([&<>\"'#\\[\\]{}])/g\n  , templateLinesRe = /^(\\ \\ )?([^\\n]+)$/gmi\n  , voids = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wrb']);\n\nlet m1: RegExpExecArray | null\n  , m2: RegExpExecArray | null\n  , m3: RegExpExecArray | null;\n\nconst entities = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&apos;',\n//  '#': '&num;',\n//  '[': '&lbrak;',\n//  ']': '&rbrak;',\n//  '{': '&rbrace;',\n//  '}': '&lbrace;',\n};\n\nfunction escape(value: string): string {\n  return value.replace(escapeRe, (match) => {\n    return entities[match] ?? match;\n  });\n}\n\nfunction makeElement(indent: number = 0): WorkingElement {\n  return {\n    indent,\n    html: '',\n    attrs: {},\n  };\n}\n\nfunction makeFragment(type: FragmentType = 'bare'): WorkingFragment {\n  return {\n    type,\n    html: '',\n    template: false,\n    mountable: false,\n    els: [],\n    refs: [],\n    mountPoints: [],\n  };\n}\n\n/**\n * Parses a longform document into a object containing the root and fragments\n * in the output format.\n *\n * @param {string} doc - The longform document to parse.\n * @returns {ParsedResult}\n */\nexport function longform(doc: string, debug: (...d: unknown[]) => void = () => {}): ParsedResult {\n  let skipping: boolean = false\n    , textIndent: number | null = null\n    , verbatimSerialize: boolean = true\n    , verbatimIndent: number | null = null\n    , verbatimFirst: boolean = false\n    , element: WorkingElement = makeElement()\n    , fragment: WorkingFragment = makeFragment()\n    // the root fragment\n    , root: WorkingFragment | null = null\n    // ids of claimed fragments\n  const claimed: Set<string> = new Set()\n    // parsed fragments\n    , parsed: Map<string, WorkingFragment> = new Map()\n    , output: ParsedResult = Object.create(null);\n\n  output.fragments = Object.create(null);\n  output.templates = Object.create(null);\n  \n  \n  /**\n   * Closes any current in progress element definition\n   * and creates a new working element.\n   */\n  function applyIndent(targetIndent: number) {\n    if (element.tag != null) {\n      const root = fragment.type === 'range'\n        ? targetIndent < 2\n        : fragment.html === ''\n      ;\n\n      fragment.html += `<${element.tag}`\n\n      if (root) {\n        if (fragment.type === 'root') {\n          fragment.html += ` data-lf-root`;\n        } else if (fragment.type === 'bare' || fragment.type === 'range') {\n          fragment.html += ` data-lf=\"${fragment.id}\"`;\n        }\n      }\n\n      if (element.mount != null) {\n        fragment.html += ` data-lf-mount=\"${element.mount}\"`;\n      }\n\n      if (element.id != null) {\n        fragment.html += ' id=\"' + element.id + '\"';\n      }\n\n      if (element.class != null) {\n        fragment.html += ' class=\"' + element.class + '\"';\n      }\n\n      for (const attr of Object.entries(element.attrs)) {\n        if (attr[1] == null) {\n          fragment.html += ' ' + attr[0]\n        } else {\n          fragment.html += ` ${attr[0]}=\"${attr[1]}\"`;\n        }\n      }\n\n      fragment.html += '>';\n\n      if (!voids.has(element.tag as string) && element.text != null) {\n        fragment.html += element.text;\n      }\n\n      if (\n        !voids.has(element.tag as string)\n      ) {\n        fragment.els.push(element);\n      }\n    }\n\n    if (targetIndent <= element.indent) {\n      element = makeElement(targetIndent);\n\n      while (\n        fragment.els.length !== 0 && (\n          targetIndent == null ||\n          fragment.els[fragment.els.length - 1].indent !== targetIndent - 1\n        )\n      ) {\n        const element = fragment.els.pop();\n\n        fragment.html += `</${element?.tag}>`;\n      }\n\n      if (targetIndent === 0) {\n        debug(0, '<', fragment.type, fragment.id);\n        if (fragment.template) {\n          output.templates[fragment.id] = fragment.html;\n        } else if (fragment.type === 'root') {\n          root = fragment;\n        } else {\n          parsed.set(fragment.id, fragment);\n        }\n\n        fragment = makeFragment();\n      }\n    } else {\n      element = makeElement(targetIndent)\n    }\n  }\n\n  while ((m1 = sniffTestRe.exec(doc))) {\n    if (m1[1] === '--') {\n      continue;\n    } else if (fragment.template) {\n      fragment.html += m1[0];\n    }\n\n    // If this is a script tag or preformatted block\n    // we want to retain the intended formatting less\n    // the indent. Preformatting can apply to any element\n    // by ending the declaration with `:: {`.\n    if (verbatimIndent != null) {\n      // inside a script or preformatted block\n      idnt1.lastIndex = 0;\n      m2 = idnt1.exec(m1[0]);\n      const indent = m2 == null\n        ? null\n        : m2[0].length / 2;\n\n      if (m2 == null || indent as number <= verbatimIndent) {\n        fragment.html += '\\n';\n        debug(indent, '}', m2?.[0]);\n\n        applyIndent(indent);\n        verbatimIndent = null;\n        verbatimFirst = false;\n        textIndent = indent;\n\n        if (preformattedClose.test(m1[0])) {\n          continue;\n        }\n      } else {\n        const line = m1[0].replace('  '.repeat(verbatimIndent + 1), '');\n        debug(indent, '{', line);\n\n        if (element.tag != null) {\n          applyIndent(indent as number);\n        }\n\n        if (verbatimFirst) {\n          verbatimFirst = false;\n        } else {\n          fragment.html += '\\n';\n        }\n        \n        if (verbatimSerialize) {\n          fragment.html += escape(line);\n        } else {\n          fragment.html += line;\n        }\n\n        continue;\n      }\n    }\n\n    if (m1[0].trim() === '') {\n      continue;\n    }\n\n    switch (m1[2] ?? m1[3] ?? m1[4]) {\n      // deno-lint-ignore no-fallthrough\n      case '#': {\n        id1.lastIndex = 0;\n        m2 = id1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n\n          if (element.tag != null || textIndent != null) {\n            applyIndent(indent);\n            textIndent = null;\n          }\n\n          debug(indent, 'id', m2[2], m2[3], m2[4]);\n\n          fragment.id = m2[3];\n\n          if (indent === 0) {\n            if (m2[4] == '[') {\n              fragment.type = 'range';\n            } else if (m2[4] === '\"') {\n              fragment.type = 'text';\n            } else if (m2[2] != null) {\n              fragment.type = 'bare';\n            } else {\n              fragment.type = 'embed';\n              element.id = fragment.id;\n            }\n          }\n\n          break;\n        }\n      }\n      case '@':\n      case '[':\n      // deno-lint-ignore no-fallthrough\n      case '::': {\n        element1.lastIndex = 0;\n        // fall through if m1[3] is a # or @\n        m2 = m1[2] ?? m1[4] != null\n           ? null\n           : element1.exec(m1[0]);\n\n        // if null then invalid element selector\n        // allow the default text case to handle\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2\n              , tg = m2[2]\n              , ar = m2[3]\n              , pr = m2[4] === '{' || m2[4] === '{{'\n          const tx = pr ? null : m2[4]\n\n          debug(indent, 'e', tg, pr, tx);\n\n          if (\n            element.tag != null ||\n            element.indent > indent\n          ) {\n            applyIndent(indent);\n          }\n\n          element.indent = indent;\n          element.tag = tg;\n\n          textIndent = null;\n          \n          if (indent === 0 && fragment.id == null) {\n            if (root != null) {\n              skipping = true;\n            } else {\n              fragment.type = 'root';\n              root = fragment;\n            }\n          }\n          \n          if (ar != null) {\n            debug(indent, 'a', ar);\n            while ((m2 = paramsRe.exec(ar))) {\n              if (m2[1] === '#') {\n                element.id = m2[2];\n              } else if (m2[1] === '.') {\n                if (element.class == null) {\n                  element.class = m2[2];\n                } else {\n                  element.class += ' ' + m2[2];\n                }\n              } else {\n                if (m2[3] === 'id') {\n                  if (element.id == null) {\n                    element.id = m2[4];\n                  }\n                } else if (m2[3] === 'class') {\n                  if (element.class == null) {\n                    element.class = m2[4]\n                  } else {\n                    element.class += ' ' + m2[4]\n                  }\n                } else {\n                  element.attrs[m2[3]] = m2[4];\n                }\n              }\n            }\n          }\n\n          // this is a hack to get temp support of mounting\n          // working. In the future it will be moved to a \n          // server specific process.\n          if (element.mount != null) {\n            const id = element.mount;\n            applyIndent(indent + 1);\n            fragment.mountPoints.push({\n              id,\n              part: fragment.html,\n            });\n            fragment.html = '';\n            applyIndent(indent);\n            break;\n          }\n\n          if (!pr && tx != null) {\n            element.text = tx;\n          } else if (pr) {\n            verbatimFirst = true;\n            verbatimIndent = indent;\n            verbatimSerialize = m2[4] === '{';\n          }\n\n          break;\n        }\n\n        attribute1.lastIndex = 0;\n        m2 = m1[2] != null\n           ? null\n           : attribute1.exec(m1[0]);\n\n        if (m2 != null && element.tag != null) {\n          debug('a', m2[2], m2[3]);\n\n          if (m2[2] === 'id') {\n            if (element.id == null) {\n              element.id = m2[3].trim();\n            }\n          } else if (m2[2] === 'class') {\n            if (element.class != null) {\n              element.class += ' ' + m2[3].trim();\n            } else {\n              element.class = m2[3].trim();\n            }\n          } else if (element.attrs[m2[2]] != null) {\n            element.attrs[m2[2]] += m2[3];\n          } else {\n            element.attrs[m2[2]] = m2[3];\n          }\n\n          break;\n        }\n\n        directive1.lastIndex = 0;\n        m2 = m1[3] != null\n            ? null \n            : directive1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n\n          if (element.tag != null || textIndent != null) {\n            applyIndent(indent);\n          }\n\n          debug(indent, 'd', m2[2], m2[3]);\n\n          switch (m2[2]) {\n            case 'doctype': {\n              fragment.html += `<!doctype ${m2[3] ?? 'html'}>`;\n              break;\n            }\n            case 'xml': {\n              fragment.html += `<?xml ${m2[3] ?? 'version=\"1.0\" encoding=\"UTF-8\"'}?>`;\n              break;\n            }\n            case 'template': {\n              let indented = false;\n              fragment.template = indent === 0;\n\n              templateLinesRe.lastIndex = sniffTestRe.lastIndex;\n              while ((m2 = templateLinesRe.exec(doc))) {\n                if (m2[1] == null && !indented && fragment.id == null) {\n                  id1.lastIndex = 0;\n                  m3 = id1.exec(m2[0]);\n\n                  if (m3 != null) fragment.id = m3[3];\n\n                  fragment.html += m2[0];\n                } else if (m2[1] == null && indented) {\n                  sniffTestRe.lastIndex = templateLinesRe.lastIndex - m2[0].length;\n                  break;\n                } else {\n                  fragment.html += '\\n' + m2[0];\n                  if (m2[1] != null) indented = true;\n                }\n              }\n\n              applyIndent(0);\n              break;\n            }\n            case 'mount': {\n              if (m2[3] == null) {\n                throw new Error('Mount points must have a name');\n              } else if (fragment.type !== 'root') {\n                throw new Error('Mounting is only allowed on a root element');\n              }\n\n              fragment.mountable = true;\n              element.mount = m2[3].trim();\n              break;\n            }\n          }\n\n          break;\n        }\n\n      }\n      default: {\n        m2 = text1.exec(m1[0]) as RegExpExecArray;\n\n        if (m2 == null) {\n          break;\n        }\n        const indent = m2[1].length / 2;\n        const tx = m2[2].trim();\n\n        debug(indent, 't', m2[2]);\n\n        if (element.tag != null) {\n          applyIndent(indent);\n\n          fragment.html += tx;\n        } else if (fragment.type === 'text' && fragment.html === '') {\n          fragment.html += tx;\n        } else {\n          fragment.html += ' ' + tx;\n        }\n\n        textIndent = indent;\n\n        while ((m2 = refRe.exec(tx))) {\n          const start = fragment.html.length + m2.index - tx.length;\n\n          fragment.refs.push({\n            id: m2[1],\n            start,\n            end: start + m2[0].length,\n          });\n        }\n\n        break;\n      }\n    }\n  }\n\n  applyIndent(0);\n\n  const arr = Array.from(parsed.values());\n\n  function flatten(fragment: WorkingFragment): WorkingFragment {\n    // work backwards so we don't change the html string length\n    // for the later replacements\n    for (let j = fragment.refs.length - 1; j >= 0; j--) {\n      const ref = fragment.refs[j];\n\n      if (claimed.has(ref.id) || !parsed.has(ref.id)) {\n        fragment.html = fragment.html.slice(0, ref.start)\n          + fragment.html.slice(ref.end)\n      } else {\n        const child = flatten(parsed.get(ref.id));\n\n        fragment.html = fragment.html.slice(0, ref.start)\n          + child.html\n          + fragment.html.slice(ref.end);\n\n        if (child.type === 'embed') {\n          claimed.add(child.id)\n        }\n      }\n    }\n\n    fragment.refs = [];\n\n    return fragment;\n  }\n\n  if (root?.mountable) {\n    output.mountable = true;\n    output.tail = root.html;\n    output.mountPoints = root.mountPoints;\n\n    return output;\n  }\n\n  for (let i = 0; i < parsed.size + 1; i++) {\n    let fragment: WorkingFragment;\n    \n    if (i === 0 && root == null) {\n      continue;\n    } else if (i === 0) {\n      fragment = root;\n    } else {\n      fragment = arr[i - 1];\n    }\n\n    if (fragment.refs.length === 0) {\n      continue;\n    }\n\n    flatten(fragment)\n  }\n\n  if (root?.html != null) {\n    output.root = root.html;\n    output.selector = `[data-lf-root]`;\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    let selector: string;\n    const fragment = arr[i];\n\n    if (fragment == null || claimed.has(fragment.id)) {\n      continue;\n    }\n\n    if (fragment.type === 'embed') {\n      selector = `[id=${fragment.id}]`;\n    } else if (fragment.type === 'bare') {\n      selector = `[data-lf=${fragment.id}]`;\n    } else if (fragment.type === 'range') {\n      selector = `[data-lf=${fragment.id}]`;\n    }\n\n    output.fragments[fragment.id] = {\n      id: fragment.id,\n      selector,\n      type: fragment.type as 'embed' | 'bare' | 'range',\n      html: fragment.html,\n    };\n  }\n\n  return output;\n}\n\n\nconst templateRe = /(?:#{([\\w][\\w\\-_]*)})|(?:#\\[([\\w][\\w\\-_]+)\\])/g;\n\n/**\n * Processes a client side Longform template to HTML fragment string.\n *\n * @param fragment    - The fragment identifier.\n * @param args        - A record of template arguments.\n * @param getFragment - A function which returns an already processed fragment's HTML string.\n * @returns The processed template.\n */\nexport function processTemplate(\n  template: string,\n  args: Record<string, string | number>,\n  getFragment: (fragment: string) => string | undefined,\n): string | undefined {\n  const lf = template.replace(templateRe, (_match, param, ref) => {\n    if (ref != null) {\n      const fragment = getFragment(ref);\n\n      if (fragment == null) return '';\n\n      return fragment;\n    }\n    \n    return args[param] != null ? escape(args[param].toString()) : '';\n  });\n\n  return Object.values(longform(lf).fragments)[0]?.html ?? null;\n}\n"],
  "mappings": "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",
  "names": ["sniffTestRe", "element1", "directive1", "attribute1", "preformattedClose", "id1", "idnt1", "text1", "paramsRe", "refRe", "escapeRe", "templateLinesRe", "voids", "m1", "m2", "m3", "entities", "escape", "value", "match", "_a", "makeElement", "indent", "makeFragment", "type", "doc", "debug", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "skipping", "textIndent", "verbatimSerialize", "verbatimIndent", "verbatimFirst", "element", "fragment", "root", "claimed", "parsed", "output", "applyIndent", "targetIndent", "attr", "line", "tg", "ar", "pr", "tx", "id", "indented", "start", "arr", "flatten", "j", "ref", "child", "i", "selector", "templateRe", "template", "args", "getFragment", "lf", "_match", "param"]
}
