<!doctype html><html lang="en"><head><title data-lf="head">Longform Markup Language</title><meta data-lf="head" name="description" content="A markup and templating language for producing HTML and XML document fragments."><meta data-lf="head" name="viewport" content="width=device-width, initial-scale=1.0"><style>:root, body {
  margin: 0;
  padding: 0;
  font-size: 18px;
  line-height: 26px;
  font-family: sans-serif;
  --body-width: 45rem;
}
body {
  padding-left: 1rem;
  padding-right: 1rem;
  padding-bottom: 5rem;
}
header, main {
  width: 100%;
  max-width: 45rem;
  margin-top: 4rem;
  margin-left: auto;
  margin-right: auto;
}
section {
  margin-bottom: 3rem;
}
hgroup p {
  font-style: italic;
}
main {
  anchor-name: --main;
}
#toc, #toc ul, #toc li {
  list-style-type: none;
}
#toc {
  padding-left: 0;
  ul {
    padding-left: 1rem;
  }
}
a:visited {
  color: blue;
}
p {
  font-size: 1rem;
}
small {
  font-size: .8rem;
}
aside:not(.warning):not(.notice) {
  font-family: serif;
  font-style: italic;
}
aside.notice {
  border: solid .25rem blue;
  padding: .25rem 1rem;
}
aside.warning {
  border: solid .25rem red;
  padding: .25rem 1rem;
}
pre {
  background-color: #e4e4e4;
  width: 100%;
  box-sizing: border-box;
  margin-bottom: 1rem;
  padding: .5rem;
  border-radius: 3px;
  overflow-x: auto;
}
dd {
  margin-left: 0;
  margin-bottom: 2rem;
}
details {
  border: solid 1px #333333;
  border-radius: 3px;
  padding: .5rem;
  >:last-child {
    margin-bottom: 0;
  }
}
@media screen and (min-width: 90rem) and (min-height: 510px) {
  #toc {
    position: fixed;
    left: calc(50dvw - 38rem);
  }
}
@media screen and (min-width: 90rem) and (max-height: 670px) {
  #toc {
    bottom: 2rem;
  }
}
</style></head><body><header><hgroup><h1>Longform Markup Language</h1><p>A markup and templating language for producing <b class=keyword> HTML</b> and <b class=keyword>XML</b> document fragments.</p></hgroup><nav><ul id="toc"><li><b><a href="#language-intro">Language Intro</a></b></li><li><b><a href="#fragments">Fragments</a></b></li><li><b><a href="#whitespace">Whitespace</a></b></li><li><b><a href="#elements">Elements</a></b></li><li><b><a href="#preformatted-blocks">Preformatted blocks</a></b></li><li><b><a href="#comments">Comments</a></b></li><li><b><a href="#embedding-fragments">Embedding fragments</a></b></li><li><b><a href="#templating">Templating</a></b></li><li><b><a href="#content-sanitization">Content sanitization</a></b></li><li><b><a href="#directives">Directives</a></b><ul><li><a href="#directive-url"><code>@url</code></a></li><li><a href="#directive-patchable"><code>@patchable</code></a></li><li><a href="#directive-doctype"><code>@doctype</code></a></li><li><a href="#directive-xml"><code>@xml</code></a></li><li><a href="#directive-template"><code>@template</code></a></li><li><a href="#directive-editable"><code>@editable</code></a></li><li><a href="#directive-global"><code>@global</code></a></li><li><a href="#directive-allow-elements"><code>@allow-elements</code></a></li><li><a href="#directive-allow-attributes"><code>@allow-attributes</code></a></li><li><a href="#directive-allow-data-attributes"><code>@allow-data-attributes</code></a></li><li><a href="#directive-allow-all"><code>@allow-all</code></a></li></ul></li></ul></nav></header><main id="main"><aside id="wip-notice" class="warning"><p><strong>This document and <a href="https://github.com/occultist-dev/longform/">the parser</a> that creates it are works in progress. View the <a href="https://github.com/occultist-dev/longform/blob/main/spec/intro.lf">Longform source file</a> to get a feel for the language.</strong></p></aside> <section id="language-intro"><h2>Language Intro</h2><p><b class=keyword>Longform</b> is an easy to read markup and templating language that outputs to <b class=keyword>HTML</b> and <b class=keyword>XML</b>. A Longform document can be parsed to a complete document in the output format or as fragments to be used by an application as a source of markup when generating a document, or manipulating <b class=keyword>DOM</b> in a browser environment.</p><h3>Example Longform markup</h3><pre><code>header::
  hgroup::
    h1:: Longform Markup Language
    p::
      A markup and templating language for producing &lt;b class=keyword&gt;HTML&lt;/b&gt;
      and &lt;b class=keyword&gt;XML&lt;/b&gt; document fragments.
</code></pre><details><summary>Result</summary><pre><samp>&lt;header&gt;
  &lt;hgroup&gt;
    &lt;h1&gt;Longform Markup Language&lt;/h1&gt;
    &lt;p&gt;
      A markup and templating language for producing &lt;b class=&quot;keyword&quot;&gt;HTML&lt;/b&gt;
      and &lt;b class=&quot;keyword&quot;&gt;XML&lt;/b&gt; document fragments.
    &lt;/p&gt;
  &lt;/hgroup&gt;
&lt;/header&gt;
</samp></pre></details><p>Unlike <b class=keyword>Markdown</b>, which is an all-round popular markup language but limited in what HTML elements and markup can be represented without extensions or falling back to HTML, the Longform syntax adds no constraints on the possible markup of the output format. As a result Longform plays well with custom HTML elements and elements and attributes which might be added to HTML in the future. And in being able to express elements such as <code>&lt;nav&gt;</code> or <code>&lt;head&gt;</code> Longform can be used effectively for static content markup for regions of the website beyond the main content.</p><p>Longform also supports directives that alter how a block of Longform or plain HTML / XML is processed. This specification will formalize directives which may be used in a browser environment using a minimal Longform parser.</p><p>For example, in a Longform template the directives <code>@allow-elements</code> and <code>@allow-attributes</code> can be used to allow user defined markup to be used in a template while filtering out any exempt markup. User input markup in the Longform syntax will have filtering rules applied by the Longform parser, while embedded HTML or XML content will require that an external serializer such as <a href=https://github.com/cure53/DOMPurify>DOMPurify</a> is configured to hook into the parser and apply the rules to the user defined content.</p><h3>Longform template using sanitization directives</h3><pre aria-describedby="template-sanitization-example"><code>@template
##card
section.card.note-#{position}::
  header::
    h3:: #{title}
    
  @allow-attributes:: lang dir
  @allow-elements:: details[open name] summary h4 p strong em a[href target]
  div.card-content::
    ##{content}
</code></pre><aside id="template-sanitization-example"><p><small>In a Longform template the <code>#{title}</code> variable expansion escapes any unsafe HTML, XML and Longform entities whereas the <code>##{content}</code> expansion will filter any elements and attributes not explicitly allowed by the directive from the resulting markup. These directives can be used many times through a document allowing user defined markup to have rules appropriate for the expanded context.</small></p></aside><p>Finally, the work in progress Longform parser is small and fast. Currently at 2.6kb when minified and gzipped and supporting many of the intended features for the browser environment. The parser is likely to grow but is unlikely to reach near the size of <b class=keyword>Commonmark</b> at 47.6kb or <b class=keyword>Marked</b> at 12kb. The parser is also fast, as it can complete its job by building up the resulting HTML fragment strings line by line instead of with a two step process of constructing and abstract syntax tree and then forming the valid output markup.</p></section> <section id="fragments"><h2>Fragments</h2><p>Longform's primary design goal is to output fragments of HTML into a form that can be merged with other sources and rendered into a complete document by another program, and to do so in such a way that a client side runtime can extract the fragments from rendered DOM and re-use those fragments in a client application without duplicating data in another form during transport.</p><p>To achieve this, depending on the fragment kind, a Longform parser will embed HTML ids or data attributes in a fragment and export additional meta information that can be embedded into the rendered document to assist the client when extracting the fragments from the rendered DOM.</p><p>Note that not all fragment kinds can be transported once in the rendered document without duplication. Text fragments allow the client to present messages where HTML markup is not supported. For example, if a client was to dynamically render an <code>aria-label</code> value, any included HTML markup would be presented or read to the user as text. By not having HTML markup wrapping the content there is no predicable and straightforward method for annotating the text fragment and for the client can extract it from the DOM.</p><p>However, allowing text only fragments makes Longform a suitable format for transporting all translatable text and markup in the language specified by the client. If all textual content is placed in a Longform document for a given language, and merged into non-textual content to make a complete application state, only the Longform document will require translation to support other languages; even if the page has lots of textual content embedded in interactive content rendered by the client.</p><h3>Fragment identification</h3><p>Most Longform fragments have a Longform identifier that appears before the their markup block. When the Longform document is parsed and exported to the parent program, each fragment, if exported, will be referencable by its fragment identifier. Within the Longform document fragments can also embed other fragments using the syntax <code>&num;[frag]</code>. This behaviour is described in detail in the <a href="#embedding-fragments">Embedding fragments section</a>. Some fragments identifiers are intended to be unique to the document, and will not embed twice, or be exported if used within the document.</p><h3>The Root Fragment</h3><p>The <b class=keyword>Root Fragment</b> is an optional fragment that has no Longform identifier. There can be only one Root Fragment in a Longform document and its primary use is for outputting complete documents.</p><p>After a Root Fragment is found in the process of parsing a Longform document, all other fragments which do not have Longform identifiers are ignored when rendering the output markup. The Root Fragment often would have the <a href="#directive-doctype"><code>@doctype</code></a> or <a href="#directive-xml"><code>@xml</code></a> directive prefixing it to add a <b class=keyword>HTML</b> doctype or <b class=keyword>XML</b> declaration prefixing the output markup.</p><h4>Example Root Fragment using the <code>@doctype</code> directive</h4><pre><code>@doctype:: html
html::
  head::
    title:: Example Root Fragment
  body::
    h1:: Example Root Fragment
</code></pre><details><summary>Result</summary><pre><samp>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Example Root Fragment&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Example Root Fragment&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</samp></pre></details><h3>Embedded fragment identifiers</h3><p>Fragments can have their Longform identifier embedded into the output markup as a HTML or XML id. Embedded fragment identifiers should be unique to both the target document and Longform document. If a Longform fragment references a fragment with an embedded identifier, any other attempts to reference the embedded fragment will be ignored by the Longform parser and the fragment will not be exported.</p><h4>Example element with an embedded identifier</h4><pre><code>#embedded-id
section::
  p:: A fragment that can be referenced by its &lt;a href=#embedded-id&gt;identifier&lt;/a&gt;
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;section id=&quot;embedded-id&quot;&gt;
  &lt;p&gt;
    A fragment that can be referenced by its &lt;a href=&quot;#embedded-id&quot;&gt;identifier&lt;/a&gt;
  &lt;/p&gt;
&lt;/section&gt;
</code></samp></pre></details><h3>Bare fragments</h3><p>Bare fragments have Longform identifiers that can be referenced many times within the same Longform document and are always outputted to be used by external software. The given Longform identifier should be written to the output markup as a data attribute by any Longform parser implementation to allow selection of the fragment in a DOM environment.</p><pre><code>##alert-something-went-wrong
dialog[open].error::
  p::
    strong:: Something went wrong!
  form[method=dialog]::
    button:: Close
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;dialog data-lf=&quot;alert-something-went-wrong&quot; open class=&quot;error&quot;&gt;
  &lt;strong&gt;Something went wrong!&lt;/strong&gt;
  &lt;form method=&quot;dialog&quot;&gt;
    &lt;button&gt;Close&lt;/botton&gt;
  &lt;/form&gt;
&lt;/dialog&gt;
</code></samp></pre></details><h3>Range fragments</h3><p>Range fragments can have more than one topmost element which are outputted as siblings. All top-most elements of the range fragment would have the same data attribute.</p><pre><code>#head-details [
  title:: The range fragment
  meta::
    [name=description]
    [content=Demonstrating the range fragment]
]
</code></pre><details><summary>Result</summary><pre><samp><code>&lt;title data-lf=&quot;head-details&quot;&gt;A range of fragments&lt;/title&gt;
&lt;meta data-lf=&quot;head-details&quot; name=&quot;description&quot; content=&quot;Demonstrating the range fragment&quot; /&gt;
</code></samp></pre></details><h3>Text fragments</h3><p>Text fragments do not include any elements. Programs using Longform output can use text fragments in locations where elements are not allowed such as HTML attributes. Text fragments are particularly useful where Longform is being used as a master document for all translated copy for a webpage.</p><pre><code>#aria-label &quot;
  Create a recipe
&quot;
</code></pre><details><summary>Result</summary><pre><samp><code>Create a recipe
</code></samp></pre></details></section> <section id="whitespace"><h2>Whitespace</h2><p>Whitespace is meaningful in <strong>Longform</strong>. Any markup indented two spaces out from an element will be outputted as a child of that element.</p><p>Some exceptions for this are when native markup of the output language and text are being processed. Or when in a <a href="#preformatted-blocks">preformatted block</a>.</p></section> <section id="elements"><h2>Declaring elements</h2><h3>Element tags</h3><p>A sole element tag can be outputted using the element name followed by two colons <code>::</code>.</p><pre><code>div::
</code></pre><h3>Element attributes</h3><p>Element attributes are declared after the tag and are wrapped in square brackets <code>[]</code>.</p><pre><code>div[data-foo=bar][aria-describedby=#baz]::
</code></pre><p>Alternatively attributes can follow directly after the element tag with 1 level of indentation.</p><pre><code>div::
  [data-foo=bar]
  [aria-describedby=#baz]
</code></pre><p>If an element is declared multiple times the content is concatenated into a single value. This behaviour does not apply to the element's id if it is defined using the attribute syntax. Classes will be concatenated with a space separating them.</p><pre><code>meta::
  [name=description]
  [content=Lorem ipsum dolor sit amet, consectetur adipiscing elit.]
  [content=Quisque a sem et nisl mollis porttitor et sit amet neque.]
  [content=Maecenas suscipit nulla ac suscipit imperdiet. Quisque]
  [content=odio nisi, semper non dui quis, feugiat faucibus ipsum.]
</code></pre><h3>Element output ids</h3><p>The elements output markup id can be declared on the line before the tag at the same indentation level with the hash <code>#</code> symbol pre-fixing the id.</p><p>This form of giving an element an id also gives it a meaningful Longform identifier.</p><pre><code>#element-id
div::
</code></pre><p>Alternatively the id can follow the tag name, before the closing semicolons. Again with a hash prefixing it. Unlike the form where the</p><pre><code>div#element-id::
</code></pre><p>And finally the id can be declared using the attribute syntax.</p><pre><code>div[id=element-id]::
&lt;!-- or --&gt;
div::
  [id=element-id]
</code></pre><p>If an element has an id declared for it twice only the first declaration is used.</p><h3>Element classes</h3><p>Classes can be defined following the element's tag declaration with a period <code>.</code> prefixing each tag.</p><pre><code>div#element-id.class-1.class-2.class-3::
</code></pre><p>Alternatively classes can be defined using the attribute syntax on the lines following the tag definition.</p><pre><code>div#element-id::
  [class=class-1]
  [class=class-2 class-3]
</code></pre><h3>Element text and native markup content.</h3><p>Elements can have text and native markup following the tag declaration with a space between the text and the double colons of the element definition.</p><pre><code>div:: Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre><p>Alternatively, the text and native markup can follow the tag declaration with one extra indentation level.</p><pre><code>div::
  Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre><h3>Chained elements</h3><aside class="notice"><p>Chained elements have not been implemented by the Longform parser.</p></aside><p>Elements can be chained to create many elements in one line.</p><pre><code>menu::
  li::a[href=/section1]::b:: Section 1
  li::a[href=/section2]::b:: Section 2
  li::a[href=/section3]::b:: Section 3
</code></pre></section> <section id="preformatted-blocks"><h2>Preformatted blocks</h2><p>Longform does not assign special meaning to any HTML tags so to retain formatting content can be wrapped in curly braces to create a preformatted block.</p><dl><dt><b>Escaped preformatted block</b></dt><dd>When an element is followed by a single curly brace, its content is HTML escaped and its whitespace is preserved at the children's indent level.<pre><code>pre::
  code:: {
    div::
      &lt;p&gt;
        This content will preserve its formatting including
        the parent &lt;code&gt;div::&lt;/code&gt;
      &lt;/p&gt;
  }
</code></pre><details><summary>Result</summary><pre><samp>&lt;pre&gt;&lt;code&gt;
  div::
    &lt;p&gt;
      This content will preserve its formatting including
      the parent &lt;code&gt;div::&lt;/code&gt;
    &lt;/p&gt;
&lt;/code&gt;&lt;/pre&gt;
</samp></pre></details></dd><dt><b>Un-escaped preformatted text</b></dt><dd>When an element is followed by a two curly braces, its formatting and content is kept intact.<pre><code>script:: {{
  console.log(&apos;Hello, World!&apos;);
}}

style:: {{
  div {
    color: red;
  }
}}
</code></pre><details><summary>Result</summary><pre><samp>&lt;script&gt;
  console.log(&apos;Hello, World!&apos;);
&lt;/script&gt;&lt;style&gt;
  div {
    color: red;
  }
&lt;/style&gt;
</samp></pre></details></dd></dl></section> <section id="comments"><h2>Comments</h2><p>Comments can be written outside of a fragment using <code>--</code> two hyphens. Within a fragment comments in the output markup language's syntax can be used but they will be written to the output alongside all other text in the native output markup.</p></section> <section id="embedding-fragments"><h2>Embedding fragments</h2><p>Fragments can be embedded into other fragments as part of the Longform parsing allowing a full document to be created from many fragments. Fragments are embedded using the syntax &num;[fragment-id].</p><pre><code>@root
@doctype:: html
html[lang=en]::
  body:: 
    header::
      menu::
        li::a[href=#section1]:: Section 1
        li::a[href=#section2]:: Section 2
    body::
      #[section1]
      #[section2]

#section1
section::
  ...

#section2
section::
  ...
</code></pre></section>  <section id="templating"><h2>Templating</h2><aside class="notice"><p>Longform templates are intended for client side templating where Javascript may be creating new markup and may format local values into the Longform markup. Future versions of this spec will include pre-processing rules for generating Longform documents using server side state and logic within the document.</p><p>When a Longform document is processed, any templates will be provided as strings indented to be re-processed using a separate template processing function which knows how to expand any variables in the template.</p></aside><p>Longform templates only allow key-value pairs inputed with the values being strings. The template is intended to be passed over to the client where the template might be rendered using client side state. It is assumed that the client has its own means to perform conditional statements and iterate, and is optimized to do so, so those functionalities are left to the scripting language to keep the templating logic lean.</p><pre><code>@template
div::
  h3:: Recipe step #{position}
</code></pre><h3>Templated markup</h3><aside class="notice"><p>Templated markup has not been implemented in the Longform parser.</p></aside><p>Arbitary Longform and HTML strings can be inserted in a template using the double hash variable expansion form. See <a href="#content-sanitization">content sanitization</a> for rules on sanitizing untrusted input using this form.</p><pre><code>@template
@allow-elements:: strong em
div::
  ##{markup}
</code></pre></section><section id="content-sanitization"><h2>Content sanitization</h2><aside class="notice"><p>Content sanitization has not been implemented in the Longform parser.</p></aside><p>A Longform block can have sanitization rules applied to its content using the <code>@allow-elements</code>, <code>@allow-attributes</code>, <code>@allow-data-attributes</code>, <code>@allow-all</code> directives. These directives are designed to play well with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Sanitizer" target="_blank"><code>SanitizerConfig</code></a> Web API, but for now a <a href="https://github.com/cure53/DOMPurify" target="_blank">sanitizer library</a> must be shipped with the parser to apply the directive rules on any content.</p><p>Sanitizer rules apply when expanding variables in a templating context using the double hash expansion syntax <code>&num;&num;{var}</code> and in situations where <code>@patchable</code> is used.</p><h3>Sanitizer defaults</h3><p>Longform cannot sanitize raw HTML without having a sanitizer library parsing HTML input and it cannot differentiated between text and HTML markup. If the double hash template expansion is used in a situation where no sanitizer is configured the variable expansion SHOULD be ignored by parser implementations. Parsers MAY support an option to bypass this default document level behaviour.</p><p>A document specifying no rules allowing elements, attributes or data attributes also SHOULD ignore all input using the double hash variable expansion. Again, a parser might allow equivalent options to the sanitizer directives to bypass this default behaviour.</p><h3>Element specific sanitizer rules</h3><p>A element can have rules applied allowing arbitary markup to be added to the document. Either <code>@allow-elements</code> or <code>@allow-all</code> must be used to allow any elements to persist.</p><pre><code>@template
#embedding-content
section::
  header::
    h2:: #{header}
  @allow-elements:: strong em a[href target]
  @allow-attributes: class
  div::
    ##{markup}
</code></pre><p>Sanitization rules are inherited by child elements. So the following Longform would produce the same results.</p><pre><code>@template
@allow-elements:: strong em a[href target]
@allow-attributes: class
#embedding-content
section::
  header::
    h2:: #{header}
  div::
    ##{markup}
</code></pre><h3>Global settings</h3><p>Settings can be configured document wide using the <code>@global</code> directive from the top level of the document.</p><pre><code>@global::
  @allow-elements:: strong em a[href target]
  @allow-attributes: class
  
@template
#template1
section::
  ##{markup}

@template
#template2
section::
  ##{markup}
</code></pre></section>    <section id="directives"><h2>Directives</h2><dl><dt id="directive-url"><b><code>@url</code></b></dt><dd><p>Sets the URL of the Longform document. A HTTP Get request to the <code>@url</code> using the <code>Accept</code> header <b>text/longform</b> should produce the same document unless it has since been modified.</p><pre><code>@url:: https://example.com/blog/article-1
</code></pre></dd><dt id="directive-patchable"><b><code>@patchable</code></b></dt><dd><p>Asserts to the client that the document can be patched using a HTTP Patch request and the <code>Content-Type</code> header <b>text/longform</b>. The <code>@patchable</code> directive should be ignored unless the <code>@url</code> directive is used.</p><pre><code>@url:: http://example.com/blog/longform-1
@patchable
</code></pre></dd><dt id="directive-doctype"><b><code>@doctype</code></b></dt><dd><p>Inserts a doctype declaration at the beginning of a fragment.</p><pre><code>@doctype:: html
html[lang=en]::
  head::
    ...
  body::
    ...
</code></pre><details><summary>Result</summary><pre><samp>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;...&lt;/head&gt;
  &lt;body&gt;...&lt;/body&gt;
&lt;/html&gt;
</samp></pre></details></dd><dt id="directive-xml"><b><code>@xml</code></b></dt><dd><p>Inserts an XML declaration at the beginning of a fragment.</p><pre><code>@xml:: version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;
html::
  [xmlns=http://www.w3.org/HTML/1998/html4]
  [xmlns:xdc=http://www.xml.com/books]
  body::
    ...
</code></pre><details><summary>Result</summary><pre><samp>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;html
  xmlns=&quot;http://www.w3.org/HTML/1998/html4&quot;
  xmlns:xdc=&quot;http://www.xml.com/books&quot;
&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;
</samp></pre></details></dd><dt id="directive-template"><b><code>@template</code></b></dt><dd><p>Marks a fragment as being a client side template. When a fragment is a template the Longform parser skips formatting the fragment and outputs it separately to the processed fragments to be passed through to the client. Client side logic can then pass the template into a special Longform template parser and have the HTML output returned.</p><pre><code>@template
#button-text &quot;
  Add new #{entityName}
&quot;
</code></pre></dd><dt id="directive-editable"><b><code>@editable</code></b></dt><dd><p>Marks the children of an element as editable in a patch request. The element cannot be within a template and must have a Longform id set on it.</p><pre><code>@editable
#edit-me
div::
  This content is editable.
</code></pre></dd><dt id="directive-global"><b><code>@global</code></b></dt><dd><p>Applies directive rules to an entire Longform document. Directives applied before or within a fragment will typically override globally set rules.</p><pre><code>@url:: https://example.com/pages/article-1
@patchable
@global::
  @allowed-elements:: h4 p strong em b i small hr br
</code></pre></dd><dt id="directive-allow-elements"><b><code>@allow-elements</code></b></dt><dd><p>In a template this directive instructs the parser what elements can be rendered when applying non-escaped variable expansion within its scope. If used in a patchable document, client side editors should limit what elements can be edited in the editable element. The directive's rules should also be used to sanitize or reject input when merging edits from a HTTP Patch request into the document on the server.</p><p>Attributes can be allowed on specific elements by listing them in square brackets directly after the element in the directive's arguments.</p><p>If this or the <code>@allow-all</code> directives are not used all elements should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-elements:: a[href target] p strong em
div::
  Edit me!
</code></pre></dd><dt id="directive-allow-attributes"><b><code>@allow-attributes</code></b></dt><dd><p>In a template this directive instructs the parser what attributes can be rendered when applying non-escaped variable expansion within its scope. If used in a patchable document client side editors can limit what attributes can be added to the markup. The directive's rules should be used to sanitize or reject input when merging edits from a HTTP Patch request into the document on the server.</p><p>If this or the <code>@allow-all</code> directives are not used all attributes should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-attributes:: id name class
@allow-elements:: a[href target] p strong em form label[for] input button[submit]
div::
  Edit me...
</code></pre></dd><dt id="directive-allow-data-attributes"><b><code>@allow-data-attributes</code></b></dt><dd><p>In a template this directive instructs the parser to allow rendering of data-attributes when applying non-escaped variable expansion within its scope. If used in a patchable document client side editors can allow data-attributes to be added to the markup.</p><p>If this or the <code>@allow-all</code> directives are not used all data-attributes should be filtered or rejected when editing or applying variable expansion.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-data-attributes
@allow-attributes:: id name class
@allow-elements:: a[href target] p strong em form label[for] input button[submit]
div::
  Edit me...
</code></pre></dd><dt id="directive-allow-all"><b><code>@allow-all</code></b></dt><dd><p>This directive instructs the parser to allow all elements, attributes and data-attributes when performing non-escaped variable expansion or when editing a patchable document.</p><p>This directive can be applied in a <code>@global</code> directive block to set the default rules for a document. The directive applied closest to a template variable expansion or editable element takes precedence.</p><pre><code>@editable
@allow-all
body::
  Edit me...
</code></pre></dd></dl></section></main></body></html>