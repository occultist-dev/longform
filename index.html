<!doctype html><html lang="en"><head><title>Longform Working Specification</title><meta name="description" content="Working specification for the markup and templating language Longform"><script>console.log('HELLO FROM JAVASCRIPT'); }</script></head><body><header><a class="to-content" href="#main">Jump to content</a><hgroup><h1>Longform Working Specification</h1><p>A markup and templating language.</p></hgroup><ul id="toc"><li><a href="#language-intro">Language Intro</a></li><li><a href="#syntax">Syntax</a></li></ul></header><main id="main"><section id="language-intro"><h2>Language Intro</h2><p><b class=keyword>Longform</b> is an easy to read markup and templating language that outputs to <b class=keyword>HTML</b> and <b class=keyword>XML</b>. A longform document can be parsed to a complete document in the output format or as fragments to be used by a application as a source of markup when generating a document, or in a DOM environment.</p><p>The Longform syntax is a superset of HTML and XML, there are no restraints on what elements it can output, so it plays well with custom elements and elements which might be added to HTML in the future. Longform also adds support for directives which can alter how a block of Longform or plain HTML / XML is processed.</p><p>For example, in a Longform template the directives <code>@allow-elements</code> and <code>@allow-attributes</code> can be used to allow user defined markup to be used in a template which only allows the specified elements to added to the final markup. User input markup in the Longform syntax will have filtering rules applied by the lonform parser, any embedded HTML or XML content will require an external serializer such as <a href=https://github.com/cure53/DOMPurify>DOMPurify</a> is configured to apply the specified rules.</p><pre aria-describedby="template-sanitization-example"><code>@template
##card
section.card::
  header::
    h3:: #{title}
  @allow-attributes:: lang dir
  @allow-elements:: details[open name] summary h4 h5 p strong em b i
  div.card-content::
    ##{content}
</code></pre><p id="template-sanitization-example"><small>In a longform template the <code>#{title}</code> variable expansion escapes any unsafe HTML and XML entities whereas the <code>#{{content}}</code> expansion will filter any elements and attributes not explicitly allowed by the directive from the resulting markup.</small></p><p>Finally, the work in progress Longform parser is small and fast. Currently at 1.8kb when minified and gzipped. This is likely to grow but is unlikely to reach the size of commonmark at 47.6kb or marked at 12kb. The parser is also faster since it can detect the need to close a tag based of the amount of whitespace in front of it instead of with an abstract syntax tree.</p></section>  <section id="elements"><h2>Declaring elements</h2><h3>Element tags</h3><p>A sole element tag can be outputted using the element name followed by two semicolons <code>::</code>.</p><pre><code>div::
</code></pre><h3>Element attributes</h3><p>Element attributes are declared after the tag and are wrapped in square brackets <code>[]</code>.</p><pre><code>div[data-foo=bar][aria-describedby=#baz]::
</code></pre><p>Alternatively attributes can follow directly after the element tag with 1 level of indentation.</p><pre><code>div::
  [data-foo=bar]
  [aria-describedby=#baz]
</code></pre><p>If an element is declared multiple times the content is concatinated into a single value. This behaviour does not apply to the element's id if it is defined using the attribute syntax. And classes will be concatinated with a space separating them.</p><pre><code>meta::
  [name=description]
  [content=Lorem ipsum dolor sit amet, consectetur adipiscing elit.]
  [content=Quisque a sem et nisl mollis porttitor et sit amet neque.]
  [content=Maecenas suscipit nulla ac suscipit imperdiet. Quisque]
  [content=odio nisi, semper non dui quis, feugiat faucibus ipsum.]
</code></pre><h3>Element output ids</h3><p>The elements output markup id can be declared on the line before the tag at the same indentation level with the hash <code>#</code> symbol pre-fixing the id.</p><pre><code>#element-id
div::
</code></pre><p>Alternatively the id can follow the tag name, before the closing semicolons. Again with a hash prefixing it. If the id had</p><pre><code>div#element-id::
</code></pre><p>And finally the id can be declared using the attribute syntax.</p><pre><code>div[id=element-id]::
&lt;!-- or --&gt;
div::
  [id=element-id]
</code></pre><p>If an element has an id declared for it twice only the first declaration is used.</p><h3>Element classes</h3><p>Classes can be defined following the element's tag declaration with a period <code>.</code> prefixing each tag.</p><pre><code>div#element-id.class-1.class-2.class-3::
</code></pre><p>Alternatively classes can be defined using the attribute syntax on the lines following the tag definition.</p><pre><code>div#element-id::
  [class=class-1]
  [class=class-2 class-3]
</code></pre><h3>Element text and native markup content.</h3><p>Elements can have text and native markup following the tag declaration with a space between the text and the double colons of the element definition.</p><pre><code>div:: Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre><p>Alternatively, the text and native markup can follow the tag declaration with one extra indentation level.</p><pre><code>div::
  Text content with &lt;em&gt;some&lt;/em&gt; native markup.
</code></pre><p><i>In conclusion</i> the Longform syntax is versatile, allowing elements to be declared without two much verbosity, unless it is required. Where Longform is best is in layout and heirachical markup. Blocks of text with inline HTML formatting often will look nicer when written in HTML.</p><h3>Preformatted text</h3><pre><code>div::
  #element-id
  button::
    [class=class1 class2]
    [class=class3]
    [type=button]
    &lt;strong&gt;Text content&lt;/strong&gt;
  button#element-id.class1.class2.class3[type=button]:: &lt;strong&gt;Text content&lt;/strong&gt;
</code></pre><h3>Whitespace</h3><p>Whitespace is meaningful in <strong>Longform</strong>. Any markup indented two spaces out from an element will be outputted as the child of that element.</p><p>Some exceptions for this are when native markup of the output language and text are being processed. Or when in a preformatted block.</p><h4>Comments</h4><p>Comments can be written outside of a fragment using <code>--</code> two hyphens. Within a fragment comments in the output markup language's syntax can be used but they will be written to the output alongside all other text in the native output markup.</p></section>    </main></body></html>