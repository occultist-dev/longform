
#head [
  title:: Longform Working Specification
  meta::
    [name=description]
    [content=Working specification for the markup and templating language Longform]
  style:: {{
    :root, body {
      margin: 0;
      padding: 0;
      font-size: 18px;
      line-height: 26px;
      font-family: sans-serif;
    }
    header, main {
      max-width: 50rem;
      margin-left: auto;
      margin-right: auto;
    }
    p {
      font-size: 1rem;
    }
    small {
      font-size: .8rem;
    }
  }}
]

@doctype:: html
html[lang=en]::
  head::
    #[head]
  body::
    header::
      hgroup::
        h1:: Longform Working Specification
        p::
          A markup and templating language.
      ul#toc::
        li::
          a[href=#language-intro]:: Language Intro
        li::
          a[href=#syntax]:: Syntax
        li::
          a[href=#fragments]:: Fragments
        li::
          a[href=#elements]:: Elements
    main#main::
      #[language-intro]
      #[syntax]
      #[fragments]
      #[elements]
      #[templates]
      #[selecting-from-dom]
      #[uri-fragments]
      #[http-patch]

#language-intro
section::
  h2:: Language Intro
  p::
    <b class=keyword>Longform</b> is an easy to read markup and templating
    language that outputs to <b class=keyword>HTML</b> and <b class=keyword>XML</b>.
    A longform document can be parsed to a complete document in the output format
    or as fragments to be used by a application as a source of markup when generating a
    document, or when manipulating DOM in a browser environment.

  pre[aria-describedby=simple-markup-example]::
    code:: {
      header::
        hgroup::
          h1:: Longform Working Specification
          p::
            A markup and templating language.
    }
  p::
    Unlike <b class=keyword>Markdown</b>, which excels in marking up article content
    but cannot express more recent additions to the HTML spec without falling back to
    HTML, the Longform syntax adds no constraints on the possible markup
    of the output format. This means Longform plays well with custom HTML elements and
    elements and attributes which might be added to HTML in the future. And in being
    able to express elements such as <code>&lt;nav&gt;</code> or <code>&lt;head&gt;</code>
    it can be used effectively for static content markup for regions of the website beyond
    the main content.
  p::
    Longform also supports directives which alter how a block of Longform or plain
    HTML / XML is processed. This specification will formalize directives which may be
    used in a browser environment using a minimal Longform parser.
  p::
    For example, in a Longform template the directives <code>@allow-elements</code> and
    <code>@allow-attributes</code> can be used to allow user defined markup to be used
    in a template while filtering out any exempt markup.
    User input markup in the Longform syntax will have filtering rules applied by the 
    Longform parser, while embedded HTML or XML content will require that an external serializer
    such as <a href=https://github.com/cure53/DOMPurify>DOMPurify</a> is configured to
    hook into the parser and apply the rules to the user defined content.

  pre[aria-describedby=template-sanitization-example]::
    code:: {
      @template
      ##card
      section.card.note-#{position}::
        header::
          h3:: #{title}

        @allow-attributes:: lang dir
        @allow-elements:: details[open name] summary h4 p strong em a[href target]
        div.card-content::
          ##{content}
    }
  p#template-sanitization-example::
    small::
      In a longform template the <code>#{title}</code> variable expansion escapes any unsafe HTML
      and XML entities whereas the <code>##{content}</code> expansion will filter any elements
      and attributes not explicitly allowed by the directive from the resulting markup. These
      directives can be used many times through a document allowing user defined markup to have
      rules appropriate for the context applied.

  p::
    Finally, the work in progress Longform parser is small and fast. Currently at 1.8kb
    when minified and gzipped and supporting most intended features for the browser environment.
    The parser is likely to grow but is unlikely to reach near the size of Commonmark at 47.6kb or
    Marked at 12kb. The parser is also fast, as it can complete its job by building up the 
    resulting HTML fragment strings line by line instead of with a two step process of constructing
    and abstract syntax tree and then forming the valid output markup.

#fragments
section::
  h2:: Fragments

  h3:: The root fragment
  p::
    The root fragment is an optional fragment that has no id. There can be only one root
    fragment in a Longform document. After a root fragment is found, all other fragments
    which do not have ids assigned are ignored when rendering the output markup
    The root fragment often would have the <code>@doctype</code> or <code>@xml</code>
    directive declared before it to add a <b class=keyword>HTML</b> doctype or
    <b class=keyword>XML</b> declaration prefixing the output markup.

  pre::
    code:: {
      @doctype:: html
      html::
        head::
          title:: Example Root Fragmeno
        body::
          h1:: Example Root Fragment
    }

  h3:: Fragments with embedded ids
  p::
    Fragments can have their id embedded into the output markup. Embedded ids should be
    unique to the target document and the Longform document. If a longform fragment
    references a fragment with an embedded id, any other attempts to reference the
    embedded fragment will be ignored by the Longform parser. Fragments with embeded
    ids will also not be exported to be used by external software if they have been
    referenced in the Longform document.

  pre::
    code:: {
      #embedded-id
      section::
        h2:: A fragment which can be referenced by its <a href="#embedded-id>id</a>
    }

  pre::
    samp::
      code:: {
        <section id="embedded-id">
          <h2>...</h2>
        </section>
      }

  
  h3:: Bare fragments
  p::
    Bare fragments have ids that can be referenced many times within the same Longform
    document and are always outputted to be used by external software. The given id is
    written to the output markup as a data attribute instead of an id.
  pre::
    code:: {
      ##bare-fragment
      p::
        This is a fragment which can be re-used many times within and outside of the
        Longform document. It might be useful for button text and other common
        terms used in a webapp.
    }
  pre::
    samp::
      code:: {
        <p data-lf="bare-fragment">...</p>
      }


  h3:: Range fragments
  p::
    Range fragments can have more than one topmost elements which are outputted alongside
    each other. Their ids are not written into the output markup but data attributes are
    so external software can select the element range in a DOM environment.

  pre::
    code:: {
      #range-fragment [
        title:: The range fragment
        meta::
          [name=description]
          [content=Demonstraiting the range fragment]
      ]
    }

  pre::
    samp::
      code:: {
        <title data-lf="range-fragment">...</title>
        <meta data-lf="range-fragment" ...>
      }
  div::
    Test

#elements
section::
  h2:: Declaring elements

  h3:: Element tags
  p::
    A sole element tag can be outputted using the element name followed
    by two semicolons <code>::</code>.

  pre::
    code:: {
      div::
    }

  h3:: Element attributes
  p::
    Element attributes are declared after the tag and are wrapped in 
    square brackets <code>[]</code>.

  pre::
    code:: {
      div[data-foo=bar][aria-describedby=#baz]::
    }

  p::
    Alternatively attributes can follow directly after the element tag
    with 1 level of indentation.
  pre::
    code:: {
      div::
        [data-foo=bar]
        [aria-describedby=#baz]
    }

  p::
    If an element is declared multiple times the content is concatinated
    into a single value. This behaviour does not apply to the element's id
    if it is defined using the attribute syntax. And classes will be
    concatinated with a space separating them.
  pre::
    code:: {
      meta::
        [name=description]
        [content=Lorem ipsum dolor sit amet, consectetur adipiscing elit.]
        [content=Quisque a sem et nisl mollis porttitor et sit amet neque.]
        [content=Maecenas suscipit nulla ac suscipit imperdiet. Quisque]
        [content=odio nisi, semper non dui quis, feugiat faucibus ipsum.]
    }

    
  h3:: Element output ids
  p::
    The elements output markup id can be declared on the line before the
    tag at the same indentation level with the hash <code>#</code> symbol
    pre-fixing the id.
  pre::
    code:: {
      #element-id
      div::
    }

  p::
    Alternatively the id can follow the tag name, before the closing semicolons.
    Again with a hash prefixing it. If the id had
  pre::
    code:: {
      div#element-id::
    }

  p::
    And finally the id can be declared using the attribute syntax.
  pre::
    code:: {
      div[id=element-id]::
      <!-- or -->
      div::
        [id=element-id]
    }

  p::
    If an element has an id declared for it twice only the first declaration is used.
  

  h3:: Element classes
  p::
    Classes can be defined following the element's tag declaration with a
    period <code>.</code> prefixing each tag.
  pre::
    code:: {
      div#element-id.class-1.class-2.class-3::
    }

  p::
    Alternatively classes can be defined using the attribute syntax
    on the lines following the tag definition.
  pre::
    code:: {
      div#element-id::
        [class=class-1]
        [class=class-2 class-3]
    }

  h3:: Element text and native markup content.
  p::
    Elements can have text and native markup following the tag declaration
    with a space between the text and the double colons of the element definition.
  pre::
    code:: {
      div:: Text content with <em>some</em> native markup.
    }

  p::
    Alternatively, the text and native markup can follow the tag declaration
    with one extra indentation level.
  pre::
    code:: {
      div::
        Text content with <em>some</em> native markup.
    }

  p::
    <i>In conclusion</i> the Longform syntax is versatile, allowing elements to be declared
    without two much verbosity, unless it is required. Where Longform is best is
    in layout and heirachical markup. Blocks of text with inline HTML formatting
    often will look nicer when written in HTML.

  h3:: Preformatted text

  pre::
    code:: {
      div::
        #element-id
        button::
          [class=class1 class2]
          [class=class3]
          [type=button]

          <strong>Text content</strong>

        button#element-id.class1.class2.class3[type=button]:: <strong>Text content</strong>
    }


  h3:: Whitespace
  p::
    Whitespace is meaningful in <strong>Longform</strong>. Any markup indented two
    spaces out from an element will be outputted as the child of that element.

  p::
    Some exceptions for this are when native markup of the output language and text
    are being processed. Or when in a preformatted block.

  h4:: Comments
  p::
    Comments can be written outside of a fragment using <code>--</code> two hyphens.
    Within a fragment comments in the output markup language's syntax can be used
    but they will be written to the output alongside all other text in the native
    output markup.
    
#templating
section::
  h2:: Templating
  p::
    Longform templates only allow key-value pairs inputed with the values being strings.
    The template is intended to be passed over to the client where the template might
    be rendered using client side state. It is assumed that the client has its
    own means to perform conditional statements and iterate, and is optimized to do so,
    so those functionalities are left to the scripting language to keep the templating logic lean.


    



