{
  "version": 3,
  "sources": ["lib/longform.ts"],
  "sourcesContent": ["import type { WorkingElement, WorkingChunk, ChunkType, WorkingFragment, FragmentType, Longform } from \"./types.ts\";\n\nconst sniffTestRe = /^(?:(?:(--).*)|(?: *(@|#).*)|(?: *[\\w\\-]+(?::[\\w\\-]+)?(?:[#.[][^\\n]+)?(::).*)|(?:  +(\\[).*)|(\\ \\ .+))$/gmi\n  , element1 = /((?:\\ \\ )+)? ?([\\w\\-]+(?::[\\w\\-]+)?)([#\\.\\[][^\\n]*)?::(?: ({|[^\\n]+))?/gmi\n  , directive1 = /((?:\\ \\ )+)? ?@([\\w][\\w\\-]+)(?::: ?([^\\n]+)?)?/gmi\n  , attribute1 = /((?:\\ \\ )+)\\[(\\w[\\w-]*(?::\\w[\\w-]*)?)(?:=([^\\n]+))?\\]/\n  , preformattedClose = /[ \\t]*}[ \\t]*/\n  , id1 = /((?:\\ \\ )+)?#(#)?([\\w\\-]+)( \\[)?/gmi\n  , idnt1 = /^(\\ \\ )+/\n  , text1 = /^((?:\\ \\ )+)([^ \\n][^\\n]*)$/i\n  , paramsRe = /(?:(#|\\.)([^#.\\[\\n]+)|(?:\\[(\\w[\\w\\-]*(?::\\w[\\w\\-]*)?)(?:=([^\\n\\]]+))?\\]))/g\n  , voids = new Set([\n    'area',\n    'base',\n    'br',\n    'col',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wrb',\n  ]);\n\nlet m1: RegExpExecArray | null\n  , m2: RegExpExecArray | null;\n\n\nfunction makeElement(indent: number = 0): WorkingElement {\n  return {\n    indent,\n    html: '',\n    attrs: {},\n  };\n}\n\nfunction makeChunk(type: ChunkType = 'parsed'): WorkingChunk {\n  return {\n    type,\n    html: '',\n    els: [],\n  };\n}\n\nfunction makeFragment(type: FragmentType = 'bare'): WorkingFragment {\n  return {\n    type,\n    html: '',\n    els: [],\n    chunks: [],\n  };\n}\n\n/**\n * Parses a longform document into a object containing the root and fragments\n * in the output format.\n *\n * @param {string} doc - The longform document to parse.\n * @returns {Longform}\n */\nexport function longform(doc: string, debug: (...d: unknown[]) => void = () => {}): Longform {\n  let foundRoot: boolean = false\n    , skipping: boolean = false\n    , verbatimIndent: number | null = null\n    , verbatimFirst: boolean = false\n    , element: WorkingElement = makeElement()\n    , chunk: WorkingChunk | null = makeChunk()\n    , fragment: WorkingFragment = makeFragment();\n  const output: Longform = Object.create(null);\n\n  output.fragments = Object.create(null);\n  \n  \n  /**\n   * Closes any current in progress element definition\n   * and creates a new working element.\n   */\n  function applyIndent(targetIndent: number) {\n    if (element.tag != null) {\n      fragment.html += `<${element.tag}`\n\n      if (element.id != null) {\n        fragment.html += ' id=\"' + element.id + '\"';\n      }\n\n      if (element.class != null) {\n        fragment.html += ' class=\"' + element.class + '\"';\n      }\n\n      for (const attr of Object.entries(element.attrs)) {\n        if (attr[1] == null) {\n          fragment.html += ' ' + attr[0]\n        } else {\n          fragment.html += ` ${attr[0]}=\"${attr[1]}\"`;\n        }\n      }\n\n      fragment.html += '>';\n\n      if (!voids.has(element.tag as string) && element.text != null) {\n        fragment.html += element.text;\n      }\n\n      if (\n        !voids.has(element.tag as string)\n      ) {\n        fragment.els.push(element);\n      }\n    }\n\n    if (targetIndent <= element.indent) {\n      element = makeElement(targetIndent);\n\n      while (\n        fragment.els.length !== 0 && (\n          targetIndent == null ||\n          fragment.els[fragment.els.length - 1].indent !== targetIndent - 1\n        )\n      ) {\n        const element = fragment.els.pop();\n\n        fragment.html += `</${element?.tag}>`;\n      }\n\n      if (targetIndent === 0) {\n        debug(0, '<', fragment.type, fragment.id);\n        if (fragment.type === 'root') {\n          output.root = fragment.html;\n        } else {\n          output.fragments[fragment.id as string] = {\n            type: fragment.type as FragmentType,\n            id: fragment.id as string,\n            html: fragment.html,\n          };\n        }\n\n        fragment = makeFragment();\n      }\n    } else {\n      element = makeElement(targetIndent)\n    }\n  }\n\n  while ((m1 = sniffTestRe.exec(doc))) {\n    if (m1[1] === '--') {\n      continue;\n    }\n\n\n    // If this is a script tag or preformatted block\n    // we want to retain the intended formatting less\n    // the indent. Preformatting can apply to any element\n    // by ending the declaration with `:: {`.\n    if (verbatimIndent != null) {\n      // inside a script or preformatted block\n      idnt1.lastIndex = 0;\n      m2 = idnt1.exec(m1[0]);\n      const indent = m2 == null\n        ? null\n        : m2[0].length / 2;\n\n      if (m2 == null || indent as number <= verbatimIndent) {\n        fragment.html += '\\n';\n        debug(indent, '}', m2?.[0]);\n\n        applyIndent(verbatimIndent);\n        verbatimIndent = null;\n\n        if (preformattedClose.test(m1[0])) {\n          continue;\n        }\n      } else {\n        const line = m1[0].replace('  '.repeat(verbatimIndent + 1), '');\n        debug(indent, '{', line);\n\n        if (element.tag != null) {\n          applyIndent(indent as number);\n        }\n\n        if (!verbatimFirst) {\n          fragment.html += '\\n';\n        } else {\n          verbatimFirst = true;\n        }\n          \n        fragment.html += line\n\n        continue;\n      }\n    }\n\n    switch (m1[2] ?? m1[3] ?? m1[4]) {\n      // deno-lint-ignore no-fallthrough\n      case '#': {\n        id1.lastIndex = 0;\n        m2 = id1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n          debug(indent, 'id', m2[2], m2[3], m2[4]);\n\n          if (element.tag != null) {\n            applyIndent(indent);\n          }\n\n          fragment.id = m2[3];\n\n          if (indent === 0) {\n            if (m2[4] != null) {\n              fragment.type = 'range';\n            } else if (m2[2] != null) {\n              fragment.type = 'bare';\n            } else {\n              fragment.type = 'embed';\n              element.id = fragment.id;\n            }\n          }\n\n          break;\n        }\n      }\n      case '@':\n      case '[':\n      // deno-lint-ignore no-fallthrough\n      case '::': {\n        element1.lastIndex = 0;\n        // fall through if m1[3] is a # or @\n        m2 = m1[2] ?? m1[4] != null\n           ? null\n           : element1.exec(m1[0]);\n\n        // if null then invalid element selector\n        // allow the default text case to handle\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2\n              , tg = m2[2]\n              , ar = m2[3]\n              , pr = m2[4] === '{'\n          const tx = pr ? null : m2[4]\n\n          debug(indent, 'e', tg, pr, tx);\n\n          if (element.tag != null || element.indent > indent) {\n            applyIndent(indent);\n          }\n          \n          if (indent === 0 && fragment.id == null) {\n            if (foundRoot) {\n              skipping = true;\n            } else {\n              fragment.type = 'root';\n              foundRoot = true;\n            }\n          }\n\n          element.indent = indent;\n          element.tag = tg;\n\n          if (ar != null) {\n            debug(indent, 'a', ar);\n            while ((m2 = paramsRe.exec(ar))) {\n              if (m2[1] === '#') {\n                element.id = m2[2];\n              } else if (m2[1] === '.') {\n                if (element.class == null) {\n                  element.class = m2[2];\n                } else {\n                  element.class += ' ' + m2[2];\n                }\n              } else {\n                if (m2[3] === 'id') {\n                  if (element.id == null) {\n                    element.id = m2[4];\n                  }\n                } else if (m2[3] === 'class') {\n                  if (element.class == null) {\n                    element.class = m2[4]\n                  } else {\n                    element.class += ' ' + m2[4]\n                  }\n                } else {\n                  element.attrs[m2[3]] = m2[4];\n                }\n              }\n            }\n          }\n\n          if (!pr && tx != null) {\n            element.text = tx;\n          } else if (pr) {\n            verbatimFirst = true;\n            verbatimIndent = indent;\n          }\n\n          break;\n        }\n\n        attribute1.lastIndex = 0;\n        m2 = m1[2] != null\n           ? null\n           : attribute1.exec(m1[0]);\n\n        if (m2 != null && element.tag != null) {\n          debug('a', m2[2], m2[3]);\n\n          if (m2[2] === 'id') {\n            if (element.id == null) {\n              element.id = m2[3].trim();\n            }\n          } else if (m2[2] === 'class') {\n            if (element.class != null) {\n              element.class += ' ' + m2[3].trim();\n            } else {\n              element.class = m2[3].trim();\n            }\n          } else if (element.attrs[m2[2]] != null) {\n            element.attrs[m2[2]] += m2[3];\n          } else {\n            element.attrs[m2[2]] = m2[3];\n          }\n\n          break;\n        }\n\n        directive1.lastIndex = 0;\n        m2 = m1[3] != null\n            ? null \n            : directive1.exec(m1[0]);\n\n        if (m2 != null) {\n          const indent = (m2[1]?.length ?? 0) / 2;\n\n          if (element.tag != null) {\n            applyIndent(indent);\n          }\n\n          switch (m2[2]) {\n            case 'doctype': {\n              fragment.html += `<!doctype ${m2[3] ?? 'html'}>`;\n              break;\n            }\n            case 'xml': {\n              fragment.html += `<?xml ${m2[3] ?? 'version=\"1.0\" encoding=\"UTF-8\"'}?>`;\n              break;\n            }\n          }\n\n          break;\n        }\n\n      }\n      default: {\n        const m2 = text1.exec(m1[0]) as RegExpExecArray;\n        if (m2 == null) {\n          break;\n        }\n        const indent = m2[1].length / 2;\n\n        debug(indent, 't', m2[2]);\n\n        if (element.tag != null) {\n          applyIndent(indent);\n\n          fragment.html += m2[2].trim();\n        } else {\n          fragment.html += ' ' + m2[2].trim();\n        }\n        break;\n      }\n    }\n  }\n\n  applyIndent(0);\n\n  return output;\n}\n"],
  "mappings": "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",
  "names": ["sniffTestRe", "element1", "directive1", "attribute1", "preformattedClose", "id1", "idnt1", "text1", "paramsRe", "voids", "m1", "m2", "makeElement", "indent", "makeChunk", "type", "makeFragment", "doc", "debug", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "_k", "foundRoot", "skipping", "verbatimIndent", "verbatimFirst", "element", "chunk", "fragment", "output", "applyIndent", "targetIndent", "attr", "line", "tg", "ar", "pr", "tx"]
}
